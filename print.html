<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Cookbook</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Collection of useful Rust code examples">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/custom.css">
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="intro.html">Table of Contents</a></li><li class="affix"><a href="about.html">About</a></li><li><a href="basics.html"><strong aria-hidden="true">1.</strong> Basics</a></li><li><a href="encoding.html"><strong aria-hidden="true">2.</strong> Encoding</a></li><li><a href="concurrency.html"><strong aria-hidden="true">3.</strong> Concurrency</a></li><li><a href="net.html"><strong aria-hidden="true">4.</strong> Networking</a></li><li><a href="app.html"><strong aria-hidden="true">5.</strong> Application development</a></li><li><a href="logging.html"><strong aria-hidden="true">6.</strong> Logging</a></li><li><a href="build_tools.html"><strong aria-hidden="true">7.</strong> Build Time Tooling</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <!-- START - Rust Cookbook customization -->
                            <button id="edit-button" class="icon-button" type="button" title="Fork and edit" aria-label="Fork and edit" aria-haspopup="true" aria-expanded="false" aria-controls="edit">
                                <i class="fa fa-edit">Edit</i>
                            </button>
                            <!-- END - Rust Cookbook customization -->
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust Cookbook</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });

                   // START - Rust Cookbook customization
                   document.getElementById("edit-button").addEventListener("click", function(){
                       var editWindow = window.open("https://github.com/rust-lang-nursery/rust-cookbook/edit/master/src/print.md");
                   });
                   // END - Rust Cookbook customization
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#cookin-with-rust" id="cookin-with-rust"><h1>Cookin' with Rust</h1></a>
<p>This <em>Rust Cookbook</em> is a collection of
simple examples that demonstrate good practices to accomplish common
programming tasks, using the crates of the Rust ecosystem.</p>
<p><a href="about.html">Read more about <em>Rust Cookbook</em></a>, including tips for
how to read the book, how to use the examples, and notes on conventions.</p>
<a class="header" href="print.html#contributing" id="contributing"><h2>Contributing</h2></a>
<p>This project is intended to be easy for new Rust programmers to
contribute to, and an easy to way get involved with the Rust
community. It needs and welcomes help. For details see
<a href="https://github.com/rust-lang-nursery/rust-cookbook/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a>.</p>
<a class="header" href="print.html#a-hrefbasicshtmlbasicsa" id="a-hrefbasicshtmlbasicsa"><h2><a href="basics.html">Basics</a></h2></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="basics.html#ex-std-read-lines">Read lines of strings from a file</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-byteorder-le">Read and write integers in little-endian byte order</a> </td><td> <a href="https://docs.rs/byteorder/"><img src="https://badge-cache.kominick.com/crates/v/byteorder.svg?label=byteorder" alt="byteorder-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-rand">Generate random numbers</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-rand-range">Generate random numbers within a range</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-rand-dist">Generate random numbers with given distribution</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-rand-custom">Generate random values of a custom type</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-rand-passwd">Create random passwords from a set of alphanumeric characters</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-rand-choose">Create random passwords from a set of user-defined characters</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-parse-subprocess-output">Run an external command and process stdout</a> </td><td> <a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> </td><td> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-parse-subprocess-input">Run an external command passing it stdin and check for an error code</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-run-piped-external-commands">Run piped external commands</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-redirect-stdout-stderr-same-file">Redirect both stdout and stderr of child process to the same file</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-continuous-process-output">Continuously process child process' outputs</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a><a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-regex-filter-log">Filter a log file by matching multiple regular expressions</a> </td><td> <a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> </td><td> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></td></tr>
<tr><td> <a href="basics.html#ex-lazy-constant">Declare lazily evaluated constant</a> </td><td> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> </td><td> <a href="https://crates.io/categories/caching"><img src="https://badge-cache.kominick.com/badge/caching--x.svg?style=social" alt="cat-caching-badge" /></a> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-global-mut-state">Maintain global mutable state</a> </td><td> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> </td><td> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-verify-extract-email">Verify and extract login from an email address</a> </td><td> <a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> </td><td> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-extract-hashtags">Extract a list of unique #Hashtags from a text</a> </td><td> <a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> </td><td> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-regex-replace-named">Replace all occurrences of one text pattern with another pattern.</a> </td><td> <a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> </td><td> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-phone">Extract phone numbers from text</a> </td><td> <a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> </td><td> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-sha-digest">Calculate the SHA-256 digest of a file</a> </td><td> <a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a> <a href="https://docs.rs/data-encoding/"><img src="https://badge-cache.kominick.com/crates/v/data-encoding.svg?label=data-encoding" alt="data-encoding-badge" /></a> </td><td> <a href="https://crates.io/categories/cryptography"><img src="https://badge-cache.kominick.com/badge/cryptography--x.svg?style=social" alt="cat-cryptography-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-hmac">Sign and verify a message with an HMAC digest</a> </td><td> <a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a> </td><td> <a href="https://crates.io/categories/cryptography"><img src="https://badge-cache.kominick.com/badge/cryptography--x.svg?style=social" alt="cat-cryptography-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-pbkdf2">Salt and hash a password with PBKDF2</a> </td><td> <a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a> <a href="https://docs.rs/data-encoding/"><img src="https://badge-cache.kominick.com/crates/v/data-encoding.svg?label=data-encoding" alt="data-encoding-badge" /></a> </td><td> <a href="https://crates.io/categories/cryptography"><img src="https://badge-cache.kominick.com/badge/cryptography--x.svg?style=social" alt="cat-cryptography-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-bitflags">Define and operate on a type represented as a bitfield</a> </td><td> <a href="https://docs.rs/bitflags/"><img src="https://badge-cache.kominick.com/crates/v/bitflags.svg?label=bitflags" alt="bitflags-badge" /></a> </td><td> <a href="https://crates.io/categories/no-std"><img src="https://badge-cache.kominick.com/badge/no_std--x.svg?style=social" alt="cat-no-std-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-random-file-access">Access a file randomly using a memory map</a> </td><td> <a href="https://docs.rs/memmap/"><img src="https://badge-cache.kominick.com/crates/v/memmap.svg?label=memmap" alt="memmap-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-check-cpu-cores">Check number of logical cpu cores</a> </td><td> <a href="https://docs.rs/num_cpus/"><img src="https://badge-cache.kominick.com/crates/v/num_cpus.svg?label=num_cpus" alt="num_cpus-badge" /></a> </td><td> <a href="https://crates.io/categories/hardware-support"><img src="https://badge-cache.kominick.com/badge/hardware_support--x.svg?style=social" alt="cat-hardware-support-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-error-chain-simple-error-handling">Handle errors correctly in main</a> </td><td> <a href="https://docs.rs/error-chain/"><img src="https://badge-cache.kominick.com/crates/v/error-chain.svg?label=error-chain" alt="error-chain-badge" /></a> </td><td> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a></td></tr>
<tr><td> <a href="basics.html#ex-error-chain-avoid-discarding">Avoid discarding errors during error conversions</a> </td><td> <a href="https://docs.rs/error-chain/"><img src="https://badge-cache.kominick.com/crates/v/error-chain.svg?label=error-chain" alt="error-chain-badge" /></a> </td><td> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-error-chain-backtrace">Obtain backtrace of complex error scenarios</a> </td><td> <a href="https://docs.rs/error-chain/"><img src="https://badge-cache.kominick.com/crates/v/error-chain.svg?label=error-chain" alt="error-chain-badge" /></a> </td><td> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-measure-elapsed-time">Measure elapsed time</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/time--x.svg?style=social" alt="cat-time-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-convert-datetime-timestamp">Convert date to UNIX timestamp and vice versa</a> </td><td> <a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> </td><td> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-convert-datetime-timezone">Convert a local time to an another UTC timezone and vice versa</a> </td><td> <a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> </td><td> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-format-datetime">Display formatted date and time</a> </td><td> <a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> </td><td> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-parse-datetime">Parse string into DateTime struct</a> </td><td> <a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> </td><td> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-datetime-arithmetic">Perform checked date and time calculations</a> </td><td> <a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> </td><td> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-examine-date-and-time">Examine the date and time</a> </td><td> <a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> </td><td> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-file-24-hours-modified">File names that have been modified in the last 24 hours for the working directory</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a> </td></tr>
</tbody></table>
<a class="header" href="print.html#a-hrefencodinghtmlencodinga" id="a-hrefencodinghtmlencodinga"><h2><a href="encoding.html">Encoding</a></h2></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="encoding.html#ex-json-value">Serialize and deserialize unstructured JSON</a> </td><td> <a href="https://docs.rs/serde_json/*/serde_json/"><img src="https://badge-cache.kominick.com/crates/v/serde_json.svg?label=serde_json" alt="serde-json-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-toml-config">Deserialize a TOML configuration file</a> </td><td> <a href="https://docs.rs/toml/"><img src="https://badge-cache.kominick.com/crates/v/toml.svg?label=toml" alt="toml-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-percent-encode">Percent-encode a string</a> </td><td> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-urlencoded">Encode a string as application/x-www-form-urlencoded</a> </td><td> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-hex-encode-decode">Encode and decode hex</a> </td><td> <a href="https://docs.rs/data-encoding/"><img src="https://badge-cache.kominick.com/crates/v/data-encoding.svg?label=data-encoding" alt="data-encoding-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-base64">Encode and decode base64</a> </td><td> <a href="https://docs.rs/base64/"><img src="https://badge-cache.kominick.com/crates/v/base64.svg?label=base64" alt="base64-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-csv-read">Read CSV records</a> </td><td> <a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-csv-delimiter">Read CSV records with different delimiter</a> </td><td> <a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-csv-filter">Filter CSV records matching a predicate</a> </td><td> <a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-invalid-csv">Handle invalid CSV data with Serde</a> </td><td> <a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-serialize-csv">Serialize records to CSV</a> </td><td> <a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-csv-serde">Serialize records to CSV using Serde</a> </td><td> <a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-csv-transform-column">Transform one column of a CSV file</a> </td><td> <a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-mime-from-string">Get MIME type from string</a> </td><td> <a href="https://docs.rs/mime/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=mime" alt="mime-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
</tbody></table>
<a class="header" href="print.html#a-hrefconcurrencyhtmlconcurrencya" id="a-hrefconcurrencyhtmlconcurrencya"><h2><a href="concurrency.html">Concurrency</a></h2></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="concurrency.html#ex-rayon-iter-mut">Mutate the elements of an array in parallel</a> </td><td> <a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a> </td></tr>
<tr><td> <a href="concurrency.html#ex-rayon-any-all">Test in parallel if any or all elements of a collection match a given predicate</a> </td><td> <a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a> </td></tr>
<tr><td> <a href="concurrency.html#ex-rayon-parallel-search">Search items using given predicate in parallel</a> </td><td> <a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a> </td></tr>
<tr><td> <a href="concurrency.html#ex-rayon-parallel-sort">Sort a vector in parallel</a> </td><td> <a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a> </td></tr>
<tr><td> <a href="concurrency.html#ex-rayon-map-reduce">Map-reduce in parallel</a> </td><td> <a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a> </td></tr>
<tr><td> <a href="concurrency.html#ex-rayon-thumbnails">Generate jpg thumbnails in parallel</a> </td><td> <a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://docs.rs/glob/"><img src="https://badge-cache.kominick.com/crates/v/glob.svg?label=glob" alt="glob-badge" /></a> <a href="https://docs.rs/image/"><img src="https://badge-cache.kominick.com/crates/v/image.svg?label=image" alt="image-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="concurrency.html#ex-crossbeam-spawn">Spawn a short-lived thread</a> </td><td> <a href="https://docs.rs/crossbeam/"><img src="https://badge-cache.kominick.com/crates/v/crossbeam.svg?label=crossbeam" alt="crossbeam-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a> </td></tr>
<tr><td> <a href="concurrency.html#ex-threadpool-fractal">Draw fractal dispatching work to a thread pool</a> </td><td> <a href="https://docs.rs/threadpool/"><img src="https://badge-cache.kominick.com/crates/v/threadpool.svg?label=threadpool" alt="threadpool-badge" /></a> <a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a> <a href="https://docs.rs/num_cpus/"><img src="https://badge-cache.kominick.com/crates/v/num_cpus.svg?label=num_cpus" alt="num_cpus-badge" /></a> <a href="https://docs.rs/image/"><img src="https://badge-cache.kominick.com/crates/v/image.svg?label=image" alt="image-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a><a href="https://crates.io/categories/rendering"><img src="https://badge-cache.kominick.com/badge/rendering--x.svg?style=social" alt="cat-rendering-badge" /></a> </td></tr>
<tr><td> <a href="concurrency.html#ex-threadpool-walk">Calculate SHA1 sum of *.iso files concurrently</a>  </td><td> <a href="https://docs.rs/threadpool/"><img src="https://badge-cache.kominick.com/crates/v/threadpool.svg?label=threadpool" alt="threadpool-badge" /></a> <a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> <a href="https://docs.rs/num_cpus/"><img src="https://badge-cache.kominick.com/crates/v/num_cpus.svg?label=num_cpus" alt="num_cpus-badge" /></a> <a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
</tbody></table>
<a class="header" href="print.html#a-hrefnethtmlnetworkinga" id="a-hrefnethtmlnetworkinga"><h2><a href="net.html">Networking</a></h2></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="net.html#ex-url-parse">Parse a URL from a string to a <code>Url</code> type</a> </td><td> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-base">Create a base URL by removing path segments</a> </td><td> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-new-from-base">Create new URLs from a base URL</a> </td><td> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-origin">Extract the URL origin (scheme / host / port)</a> </td><td> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-rm-frag">Remove fragment identifiers and query pairs from a URL</a> </td><td> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-basic">Make a HTTP GET request</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-download">Download a file to a temporary directory</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/tempdir/"><img src="https://badge-cache.kominick.com/crates/v/tempdir.svg?label=tempdir" alt="tempdir-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-rest-get">Query the GitHub API</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-paginated-api">Consume a paginated RESTful API</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-rest-head">Check if an API resource exists</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-rest-custom-params">Set custom headers and URL parameters for a REST request</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/hyper/"><img src="https://badge-cache.kominick.com/crates/v/hyper.svg?label=hyper" alt="hyper-badge" /></a> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-rest-post">Create and delete Gist with GitHub API</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-file-post">POST a file to paste-rs</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-random-port-tcp">Listen on unused port TCP/IP</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-extract-links-webpage">Extract all links from a webpage HTML</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/select/"><img src="https://badge-cache.kominick.com/crates/v/select.svg?label=select" alt="select-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-check-broken-links">Check webpage for broken links</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/select/"><img src="https://badge-cache.kominick.com/crates/v/select.svg?label=select" alt="select-badge" /></a> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-extract-mediawiki-links">Extract all unique links from a MediaWiki markup</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-progress-with-range">Make a partial download with HTTP range headers</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-handle-rate-limited-api">Handle a rate-limited API</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/hyper/"><img src="https://badge-cache.kominick.com/crates/v/hyper.svg?label=hyper" alt="hyper-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-http-response-mime-type">Parse the MIME type of a HTTP response</a> </td><td> <a href="https://docs.rs/mime/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=mime" alt="mime-badge" /></a> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
</tbody></table>
<a class="header" href="print.html#a-hrefapphtmlapplication-developmenta" id="a-hrefapphtmlapplication-developmenta"><h2><a href="app.html">Application development</a></h2></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="app.html#ex-clap-basic">Parse command line arguments</a> </td><td> <a href="https://docs.rs/clap/"><img src="https://badge-cache.kominick.com/crates/v/clap.svg?label=clap" alt="clap-badge" /></a> </td><td> <a href="https://crates.io/categories/command-line-interface"><img src="https://badge-cache.kominick.com/badge/command_line--x.svg?style=social" alt="cat-command-line-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-tar-decompress">Decompress a tarball</a> </td><td> <a href="https://docs.rs/flate2/"><img src="https://badge-cache.kominick.com/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://badge-cache.kominick.com/crates/v/tar.svg?label=tar" alt="tar-badge" /></a> </td><td> <a href="https://crates.io/categories/compression"><img src="https://badge-cache.kominick.com/badge/compression--x.svg?style=social" alt="cat-compression-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-tar-compress">Compress a directory into a tarball</a> </td><td> <a href="https://docs.rs/flate2/"><img src="https://badge-cache.kominick.com/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://badge-cache.kominick.com/crates/v/tar.svg?label=tar" alt="tar-badge" /></a> </td><td> <a href="https://crates.io/categories/compression"><img src="https://badge-cache.kominick.com/badge/compression--x.svg?style=social" alt="cat-compression-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-tar-strip-prefix">Decompress a tarball while removing a prefix from the paths</a> </td><td> <a href="https://docs.rs/flate2/"><img src="https://badge-cache.kominick.com/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://badge-cache.kominick.com/crates/v/tar.svg?label=tar" alt="tar-badge" /></a> </td><td> <a href="https://crates.io/categories/compression"><img src="https://badge-cache.kominick.com/badge/compression--x.svg?style=social" alt="cat-compression-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-avoid-read-write">Avoid writing and reading from a same file</a> </td><td> <a href="https://docs.rs/same-file/"><img src="https://badge-cache.kominick.com/crates/v/same_file.svg?label=same_file" alt="same_file-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-find-file-loops">Find loops for a given path</a> </td><td> <a href="https://docs.rs/same-file/"><img src="https://badge-cache.kominick.com/crates/v/same_file.svg?label=same_file" alt="same_file-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-dedup-filenames">Recursively find duplicate file names</a> </td><td> <a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-file-predicate">Recursively find all files with given predicate</a> </td><td> <a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-file-skip-dot">Traverse directories while skipping dotfiles</a> </td><td> <a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-file-sizes">Recursively calculate file sizes at given depth</a> </td><td> <a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-glob-recursive">Find all png files recursively</a> </td><td> <a href="https://docs.rs/glob/"><img src="https://badge-cache.kominick.com/crates/v/glob.svg?label=glob" alt="glob-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-glob-with">Find all files with given pattern ignoring filename case</a> </td><td> <a href="https://docs.rs/glob/"><img src="https://badge-cache.kominick.com/crates/v/glob.svg?label=glob" alt="glob-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-semver-increment">Parse and increment a version string</a> </td><td> <a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a> </td><td> <a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-semver-complex">Parse a complex version string</a> </td><td> <a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a> </td><td> <a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-semver-prerelease">Check if given version is pre-release</a> </td><td> <a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a> </td><td> <a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-semver-latest">Find the latest version satisfying given range</a> </td><td> <a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a> </td><td> <a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a> </td></tr>
<tr><td> <a href="app.html#ex-semver-command">Check external command version for compatibility</a> </td><td> <a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a> </td><td> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></td></tr>
</tbody></table>
<a class="header" href="print.html#a-hreflogginghtmllogginga" id="a-hreflogginghtmllogginga"><h2><a href="logging.html">Logging</a></h2></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="logging.html#ex-log-debug">Log a debug message to the console</a> </td><td> <a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="logging.html#ex-log-error">Log an error message to the console</a> </td><td> <a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="logging.html#ex-log-mod">Enable log levels per module</a> </td><td> <a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="logging.html#ex-log-stdout">Log to stdout instead of stderr</a> </td><td> <a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="logging.html#ex-log-custom-logger">Log messages with a custom logger</a> </td><td> <a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="logging.html#ex-log-env-variable">Use a custom environment variable to set up logging</a> </td><td> <a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="logging.html#ex-log-timestamp">Include timestamp in log messages</a> </td><td> <a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> <a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="logging.html#ex-log-syslog">Log to the Unix syslog</a> </td><td> <a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/syslog/"><img src="https://badge-cache.kominick.com/crates/v/syslog.svg?label=syslog" alt="syslog-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="logging.html#ex-log-custom">Log messages to a custom location</a> </td><td> <a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/log4rs/"><img src="https://badge-cache.kominick.com/crates/v/log4rs.svg?label=log4rs" alt="log4rs-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a> </td></tr>
</tbody></table>
<a class="header" href="print.html#a-hrefbuild_toolshtmlbuild-time-toolinga" id="a-hrefbuild_toolshtmlbuild-time-toolinga"><h2><a href="build_tools.html">Build Time Tooling</a></h2></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="build_tools.html#ex-cc-static-bundled">Compile and link statically to a bundled C library</a> </td><td> <a href="https://docs.rs/cc"><img src="https://badge-cache.kominick.com/crates/v/cc.svg?label=cc" alt="cc-badge" /></a> </td><td> <a href="https://crates.io/categories/development-tools"><img src="https://badge-cache.kominick.com/badge/development_tools--x.svg?style=social" alt="cat-development-tools-badge" /></a> </td></tr>
<tr><td> <a href="build_tools.html#ex-cc-static-bundled-cpp">Compile and link statically to a bundled C++ library</a>  </td><td> <a href="https://docs.rs/cc"><img src="https://badge-cache.kominick.com/crates/v/cc.svg?label=cc" alt="cc-badge" /></a> </td><td> <a href="https://crates.io/categories/development-tools"><img src="https://badge-cache.kominick.com/badge/development_tools--x.svg?style=social" alt="cat-development-tools-badge" /></a> </td></tr>
<tr><td> <a href="build_tools.html#ex-cc-custom-defines">Compile a C library while setting custom defines</a> </td><td> <a href="https://docs.rs/cc"><img src="https://badge-cache.kominick.com/crates/v/cc.svg?label=cc" alt="cc-badge" /></a> </td><td> <a href="https://crates.io/categories/development-tools"><img src="https://badge-cache.kominick.com/badge/development_tools--x.svg?style=social" alt="cat-development-tools-badge" /></a> </td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<!-- Examples -->
<a class="header" href="print.html#about-cookin-with-rust" id="about-cookin-with-rust"><h1>About &quot;Cookin' with Rust&quot;</h1></a>
<a class="header" href="print.html#table-of-contents" id="table-of-contents"><h2>Table of contents</h2></a>
<ul>
<li><a href="print.html#who-this-book-is-for">Who this book is for</a></li>
<li><a href="print.html#how-to-read-this-book">How to read this book</a></li>
<li><a href="print.html#how-to-use-the-recipes">How to use the recipes</a></li>
<li><a href="print.html#a-note-about-error-handling">A note about error handling</a></li>
<li><a href="print.html#a-note-about-crate-representation">A note about crate representation</a></li>
</ul>
<a class="header" href="print.html#who-this-book-is-for" id="who-this-book-is-for"><h2>Who this book is for</h2></a>
<p>This cookbook is intended for new Rust programmers, so that they may
quickly get an overview of the capabilities of the Rust crate
ecosystem. It is also intended for experienced Rust programmers, who
should find in the recipes an easy reminder of how to accomplish
common tasks.</p>
<a class="header" href="print.html#how-to-read-this-book" id="how-to-read-this-book"><h2>How to read this book</h2></a>
<p>The cookbook <a href="intro.html">index</a> contains the full list of recipes, organized into
a number of sections: &quot;basics&quot;, &quot;encoding&quot;, &quot;concurrency&quot;, etc.  The
sections themselves are more or less ordered in progression, with
later sections being more advanced, and occasionally building on
concepts from earlier sections.</p>
<p>Within the index, each section contains a list of recipes. The recipes
are simple statements of a task to accomplish, like &quot;generate random
numbers in a range&quot;; and each recipe is tagged with badges indicating
which <em>crates</em> they use, like <a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a>, and which
categories on <a href="https://crates.io">crates.io</a> those crates belong to, like
<a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a>.</p>
<p>New Rust programmers should be comfortable reading from the first
section to the last, and doing so should give one a strong overview of
the crate ecosystem. Click on the section header in the index, or in
the sidebar to navigate to the page for that section of the book.</p>
<p>If you are simply looking for the solution to a simple task, the
cookbook is today more difficult to navigate. The easiest way to find
a specific recipe is to scan the index looking for the crates and
categories one is interested in. From there, click on the name of the
recipe to view it. This will improve in the future.</p>
<a class="header" href="print.html#how-to-use-the-recipes" id="how-to-use-the-recipes"><h2>How to use the recipes</h2></a>
<p>Recipes are designed to give you instant access to working code, along
with a full explanation of what it is doing, and to guide you to
further information.</p>
<p>All recipes in the cookbook are full, self contained programs, so
that they may be copied directly into your own projects for
experimentation. To do so follow the instructions below.</p>
<p>Consider this example for &quot;generate random numbers within a range&quot;:</p>
<p><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;
use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();
    println!(&quot;Random f64: {}&quot;, rng.gen::&lt;f64&gt;());
}
</code></pre></pre>
<p>To work with it locally we can run the following commands to create
a new cargo project, and change to that directory:</p>
<pre><code class="language-sh">cargo new my-example --bin
cd my-example
</code></pre>
<p>Now, we also need to add the necessary crates to <a href="http://doc.crates.io/manifest.html">Cargo.toml</a>, as
indicated by the crate badges, in this case just &quot;rand&quot;. To do so,
we'll use the <code>cargo add</code> command, which is provided by the
<a href="https://github.com/killercup/cargo-edit"><code>cargo-edit</code></a> crate, which we need to install first:</p>
<pre><code class="language-sh">cargo install cargo-edit
cargo add rand
</code></pre>
<p>Now you can replace <code>src/main.rs</code> with the full contents of the
example and run it:</p>
<pre><code class="language-sh">cargo run
</code></pre>
<p>The crate badges that accompany the examples link to the crates' full
documentation on <a href="https://docs.rs">docs.rs</a>, and is often the next documentation you
should read after deciding which crate suites your purpose.</p>
<a class="header" href="print.html#a-note-about-error-handling" id="a-note-about-error-handling"><h2>A note about error handling</h2></a>
<p>Error handling in Rust is robust when done correctly, but in today's
Rust it requires a fair bit of boilerplate. Because of this one often
sees Rust examples filled with <code>unwrap</code> calls instead of proper error
handling.</p>
<p>Since these recipes are intended to be reused as-is and encourage best
practices, they set up error handling correctly when there are
<code>Result</code> types involved.</p>
<p>The basic pattern we use is to have a <code>fn run() -&gt; Result</code> that acts
like the &quot;real&quot; main function. We use the <a href="https://docs.rs/error-chain/">error-chain</a> crate to make
<code>?</code> work within <code>run</code>.</p>
<p>The structure generally looks like:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate error_chain;

use std::net::IpAddr;
use std::str;

error_chain! {
    foreign_links {
        Utf8(std::str::Utf8Error);
        AddrParse(std::net::AddrParseError);
    }
}

fn run() -&gt; Result&lt;()&gt; {
    let bytes = b&quot;2001:db8::1&quot;;

    // Bytes to string.
    let s = str::from_utf8(bytes)?;

    // String to IP address.
    let addr: IpAddr = s.parse()?;

    println!(&quot;{:?}&quot;, addr);
    Ok(())
}

quick_main!(run);
</code></pre></pre>
<p>This is using the <code>error_chain!</code> macro to define a custom <code>Error</code> and
<code>Result</code> type, along with automatic conversions from two standard
library error types. The automatic conversions make the <code>?</code> operator
work. The <code>quick_main!</code> macro generates the actual <code>main</code> function and
prints out the error if one occurred.</p>
<p>For the sake of readability error handling boilerplate is hidden by
default like below.  In order to read full contents click on the
&quot;expand&quot; (<i class="fa fa-expand"></i>) button located in the top
right corner of the snippet.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::{Url, Position};
#
# error_chain! {
#     foreign_links {
#         UrlParse(url::ParseError);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let parsed = Url::parse(&quot;https://httpbin.org/cookies/set?k2=v2&amp;k1=v1&quot;)?;
    let cleaned: &amp;str = &amp;parsed[..Position::AfterPath];
    println!(&quot;cleaned: {}&quot;, cleaned);
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p>For more background on error handling in Rust, read <a href="https://doc.rust-lang.org/book/error-handling.html">this page of the
Rust book</a> and <a href="https://brson.github.io/2016/11/30/starting-with-error-chain">this blog post</a>.</p>
<a class="header" href="print.html#a-note-about-crate-representation" id="a-note-about-crate-representation"><h2>A note about crate representation</h2></a>
<p>This cookbook is intended eventually to provide expansive coverage of
the Rust crate ecosystem, but today is limited in scope while we get
it bootstrapped and work on the presentation. Hopefully, starting
from a small scope and slowly expanding will help the cookbook become
a high-quality resource sooner, and allow it to maintain consistent
quality levels as it grows.</p>
<p>At present the cookbook is focused on the standard library, and on
&quot;core&quot;, or &quot;foundational&quot;, crates—those crates that make up the most
common programming tasks, and that the rest of the ecosystem builds
off of.</p>
<p>The cookbook is closely tied to the <a href="https://internals.rust-lang.org/t/rust-libz-blitz/5184">Rust Libz Blitz</a>, a project to
identify, and improve the quality of such crates, and so it largely
defers crate selection to that project. Any crates that have already
been evaluated as part of that process are in scope for the cookbook,
as are crates that are pending evaluation.</p>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<a class="header" href="print.html#basics" id="basics"><h1>Basics</h1></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="print.html#ex-std-read-lines">Read lines of strings from a file</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-byteorder-le">Read and write integers in little-endian byte order</a> </td><td> <a href="https://docs.rs/byteorder/"><img src="https://badge-cache.kominick.com/crates/v/byteorder.svg?label=byteorder" alt="byteorder-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rand">Generate random numbers</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rand-range">Generate random numbers within a range</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rand-dist">Generate random numbers with given distribution</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rand-custom">Generate random values of a custom type</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rand-passwd">Create random passwords from a set of alphanumeric characters</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rand-choose">Create random passwords from a set of user-defined characters</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-parse-subprocess-output">Run an external command and process stdout</a> </td><td> <a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> </td><td> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-parse-subprocess-input">Run an external command passing it stdin and check for an error code</a> </td><td> <a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> </td><td> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-run-piped-external-commands">Run piped external commands</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-redirect-stdout-stderr-same-file">Redirect both stdout and stderr of child process to the same file</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-continuous-process-output">Continuously process child process' outputs</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a><a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-regex-filter-log">Filter a log file by matching multiple regular expressions</a> </td><td> <a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> </td><td> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></td></tr>
<tr><td> <a href="print.html#ex-lazy-constant">Declare lazily evaluated constant</a> </td><td> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> </td><td> <a href="https://crates.io/categories/caching"><img src="https://badge-cache.kominick.com/badge/caching--x.svg?style=social" alt="cat-caching-badge" /></a> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-global-mut-state">Maintain global mutable state</a> </td><td> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> </td><td> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-verify-extract-email">Verify and extract login from an email address</a> </td><td> <a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> </td><td> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-extract-hashtags">Extract a list of unique #Hashtags from a text</a> </td><td> <a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> </td><td> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-regex-replace-named">Replace all occurrences of one text pattern with another pattern.</a> </td><td> <a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> </td><td> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-phone">Extract phone numbers from text</a> </td><td> <a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> </td><td> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-sha-digest">Calculate the SHA-256 digest of a file</a> </td><td> <a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a> <a href="https://docs.rs/data-encoding/"><img src="https://badge-cache.kominick.com/crates/v/data-encoding.svg?label=data-encoding" alt="data-encoding-badge" /></a> </td><td> <a href="https://crates.io/categories/cryptography"><img src="https://badge-cache.kominick.com/badge/cryptography--x.svg?style=social" alt="cat-cryptography-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-hmac">Sign and verify a message with an HMAC digest</a> </td><td> <a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a> </td><td> <a href="https://crates.io/categories/cryptography"><img src="https://badge-cache.kominick.com/badge/cryptography--x.svg?style=social" alt="cat-cryptography-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-pbkdf2">Salt and hash a password with PBKDF2</a> </td><td> <a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a> <a href="https://docs.rs/data-encoding/"><img src="https://badge-cache.kominick.com/crates/v/data-encoding.svg?label=data-encoding" alt="data-encoding-badge" /></a> </td><td> <a href="https://crates.io/categories/cryptography"><img src="https://badge-cache.kominick.com/badge/cryptography--x.svg?style=social" alt="cat-cryptography-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-bitflags">Define and operate on a type represented as a bitfield</a> </td><td> <a href="https://docs.rs/bitflags/"><img src="https://badge-cache.kominick.com/crates/v/bitflags.svg?label=bitflags" alt="bitflags-badge" /></a> </td><td> <a href="https://crates.io/categories/no-std"><img src="https://badge-cache.kominick.com/badge/no_std--x.svg?style=social" alt="cat-no-std-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-random-file-access">Access a file randomly using a memory map</a> </td><td> <a href="https://docs.rs/memmap/"><img src="https://badge-cache.kominick.com/crates/v/memmap.svg?label=memmap" alt="memmap-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-check-cpu-cores">Check number of logical cpu cores</a> </td><td> <a href="https://docs.rs/num_cpus/"><img src="https://badge-cache.kominick.com/crates/v/num_cpus.svg?label=num_cpus" alt="num_cpus-badge" /></a> </td><td> <a href="https://crates.io/categories/hardware-support"><img src="https://badge-cache.kominick.com/badge/hardware_support--x.svg?style=social" alt="cat-hardware-support-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-error-chain-simple-error-handling">Handle errors correctly in main</a> </td><td> <a href="https://docs.rs/error-chain/"><img src="https://badge-cache.kominick.com/crates/v/error-chain.svg?label=error-chain" alt="error-chain-badge" /></a> </td><td> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-error-chain-avoid-discarding">Avoid discarding errors during error conversions</a> </td><td> <a href="https://docs.rs/error-chain/"><img src="https://badge-cache.kominick.com/crates/v/error-chain.svg?label=error-chain" alt="error-chain-badge" /></a> </td><td> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-error-chain-backtrace">Obtain backtrace of complex error scenarios</a> </td><td> <a href="https://docs.rs/error-chain/"><img src="https://badge-cache.kominick.com/crates/v/error-chain.svg?label=error-chain" alt="error-chain-badge" /></a> </td><td> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-measure-elapsed-time">Measure elapsed time</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/time--x.svg?style=social" alt="cat-time-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-convert-datetime-timestamp">Convert date to UNIX timestamp and vice versa</a> </td><td> <a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> </td><td> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-convert-datetime-timezone">Convert a local time to an another UTC timezone and vice versa</a> </td><td> <a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> </td><td> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-format-datetime">Display formatted date and time</a> </td><td> <a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> </td><td> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-parse-datetime">Parse string into DateTime struct</a> </td><td> <a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> </td><td> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-datetime-arithmetic">Perform checked date and time calculations</a> </td><td> <a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> </td><td> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-examine-date-and-time">Examine the date and time</a> </td><td> <a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> </td><td> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-file-24-hours-modified">File names that have been modified in the last 24 hours for the working directory</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a> </td></tr>
</tbody></table>
<p><a name="ex-std-read-lines"></a></p>
<a class="header" href="print.html#read-lines-of-strings-from-a-file" id="read-lines-of-strings-from-a-file"><h2>Read lines of strings from a file</h2></a>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Writes a three-line message to a file, then reads it back a line at a
time with the <a href="https://doc.rust-lang.org/std/io/struct.Lines.html"><code>Lines</code></a> iterator created by
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html#method.lines"><code>BufRead::lines</code></a>. <a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>BufRead</code></a> is a trait, and the most common way to
get one is from a <a href="https://doc.rust-lang.org/std/io/struct.BufReader.html"><code>BufReader</code></a>, which is constructed from some type
that implements <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a>, here a <a href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>File</code></a>. The <a href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>File</code></a> is opened
for writing with <a href="https://doc.rust-lang.org/std/fs/struct.File.html#method.create"><code>File::create</code></a>, and reading with <a href="https://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>File::open</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
#
use std::fs::File;
use std::io::{Write, BufReader, BufRead};
#
# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let path = &quot;lines.txt&quot;;

    let mut output = File::create(path)?;
    write!(output, &quot;Rust\n💖\nFun&quot;)?;

    let input = File::open(path)?;
    let buffered = BufReader::new(input);

    for line in buffered.lines() {
        println!(&quot;{}&quot;, line?);
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-byteorder-le"></a></p>
<a class="header" href="print.html#read-and-write-integers-in-little-endian-byte-order" id="read-and-write-integers-in-little-endian-byte-order"><h2>Read and write integers in little-endian byte order</h2></a>
<p><a href="https://docs.rs/byteorder/"><img src="https://badge-cache.kominick.com/crates/v/byteorder.svg?label=byteorder" alt="byteorder-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate byteorder;

use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};

#[derive(Default, PartialEq, Debug)]
struct Payload {
    kind: u8,
    value: u16,
}
#
# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let original_payload = Payload::default();
    let encoded_bytes = encode(&amp;original_payload)?;
    let decoded_payload = decode(&amp;encoded_bytes)?;
    assert_eq!(original_payload, decoded_payload);
    Ok(())
}

fn encode(payload: &amp;Payload) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let mut bytes = vec![];
    bytes.write_u8(payload.kind)?;
    bytes.write_u16::&lt;LittleEndian&gt;(payload.value)?;
    Ok(bytes)
}

fn decode(mut bytes: &amp;[u8]) -&gt; Result&lt;Payload&gt; {
    let payload = Payload {
        kind: bytes.read_u8()?,
        value: bytes.read_u16::&lt;LittleEndian&gt;()?,
    };
    Ok(payload)
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-rand"></a></p>
<a class="header" href="print.html#generate-random-numbers" id="generate-random-numbers"><h2>Generate random numbers</h2></a>
<p><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>Generates random numbers with help of random-number
generator <a href="https://docs.rs/rand/*/rand/trait.Rng.html"><code>rand::Rng</code></a> obtained via <a href="https://docs.rs/rand/*/rand/fn.thread_rng.html"><code>rand::thread_rng</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use rand::Rng;

fn main() {
    // Each thread has an automatically-initialised random number generator:
    let mut rng = rand::thread_rng();

    // Integers are uniformly distributed over the type's whole range:
    let n1: u8 = rng.gen();
    let n2: u16 = rng.gen();
    println!(&quot;Random u8: {}&quot;, n1);
    println!(&quot;Random u16: {}&quot;, n2);
    println!(&quot;Random u32: {}&quot;, rng.gen::&lt;u32&gt;());
    println!(&quot;Random i32: {}&quot;, rng.gen::&lt;i32&gt;());

    // Floating point numbers are uniformly distributed in the half-open range [0, 1)
    println!(&quot;Random float: {}&quot;, rng.gen::&lt;f64&gt;());
}
</code></pre></pre>
<p><a name="ex-rand-range"></a></p>
<a class="header" href="print.html#generate-random-numbers-within-a-range" id="generate-random-numbers-within-a-range"><h2>Generate random numbers within a range</h2></a>
<p><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>Generates a random value within half-open <code>[0, 10)</code> range (not including <code>10</code>) with <a href="https://docs.rs/rand/*/rand/trait.Rng.html#method.gen_range"><code>Rng::gen_range</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();
    println!(&quot;Integer: {}&quot;, rng.gen_range(0, 10));
    println!(&quot;Float: {}&quot;, rng.gen_range(0.0, 10.0));
}
</code></pre></pre>
<p>Alternatively, one can use <a href="https://docs.rs/rand/*/rand/distributions/#reexports"><code>Range</code></a> to obtain values with <a href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)">uniform distribution</a>.
This has the same effect, but may be faster when repeatedly generating numbers
in the same range.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use rand::distributions::{Range, Distribution};

fn main() {
    let mut rng = rand::thread_rng();
    let die = Range::new(1, 7);

    loop {
        let throw = die.sample(&amp;mut rng);
        println!(&quot;Roll the die: {}&quot;, throw);
        if throw == 6 {
            break;
        }
    }
}
</code></pre></pre>
<p><a name="ex-rand-dist"></a></p>
<a class="header" href="print.html#generate-random-numbers-with-given-distribution" id="generate-random-numbers-with-given-distribution"><h2>Generate random numbers with given distribution</h2></a>
<p><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>By default, random numbers are generated with <a href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)">uniform distribution</a>.
To generate numbers with other distributions you instantiate a
distribution, then sample from that distribution using
<a href="https://docs.rs/rand/*/rand/distributions/trait.Distribution.html#tymethod.sample"><code>Distribution::sample</code></a> with help of a random-number
generator <a href="https://docs.rs/rand/*/rand/trait.Rng.html"><code>rand::Rng</code></a>.</p>
<p>The <a href="https://docs.rs/rand/*/rand/distributions/index.html">distributions available are documented here</a>. An example using the
<a href="https://docs.rs/rand/*/rand/distributions/normal/struct.Normal.html"><code>Normal</code></a> distribution is shown below.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use rand::distributions::{Normal, Distribution};

fn main() {
    let mut rng = rand::thread_rng();

    // mean 2, standard deviation 3:
    let normal = Normal::new(2.0, 3.0);
    let v = normal.sample(&amp;mut rng);
    println!(&quot;{} is from a N(2, 9) distribution&quot;, v)
}
</code></pre></pre>
<p><a name="ex-rand-custom"></a></p>
<a class="header" href="print.html#generate-random-values-of-a-custom-type" id="generate-random-values-of-a-custom-type"><h2>Generate random values of a custom type</h2></a>
<p><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>Randomly generates a tuple <code>(i32, bool, f64)</code> and variable of user defined type <code>Point</code>.
Implements the <a href="https://docs.rs/rand/*/rand/distributions/trait.Distribution.html"><code>Distribution</code></a> trait on type <code>Point</code> for <a href="https://docs.rs/rand/*/rand/distributions/struct.Standard.html"><code>Standard</code></a> in order to allow random generation.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use rand::Rng;
use rand::distributions::{Distribution, Standard};

#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

impl Distribution&lt;Point&gt; for Standard {
    fn sample&lt;R: Rng + ?Sized&gt;(&amp;self, rng: &amp;mut R) -&gt; Point {
        let (rand_x, rand_y) = rng.gen();
        Point {
            x: rand_x,
            y: rand_y,
        }
    }
}

fn main() {
    let mut rng = rand::thread_rng();
    let rand_tuple = rng.gen::&lt;(i32, bool, f64)&gt;();
    let rand_point: Point = rng.gen();
    println!(&quot;Random tuple: {:?}&quot;, rand_tuple);
    println!(&quot;Random Point: {:?}&quot;, rand_point);
}
</code></pre></pre>
<p><a name="ex-rand-passwd"></a></p>
<a class="header" href="print.html#create-random-passwords-from-a-set-of-alphanumeric-characters" id="create-random-passwords-from-a-set-of-alphanumeric-characters"><h2>Create random passwords from a set of alphanumeric characters</h2></a>
<p><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></p>
<p>Randomly generates a string of given length ASCII characters in the range <code>A-Z, a-z, 0-9</code>, with <a href="https://docs.rs/rand/*/rand/distributions/struct.Alphanumeric.html#struct.Alphanumaric"><code>Alphanumeric</code></a> sample.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use rand::{thread_rng, Rng};
use rand::distributions::Alphanumeric;

fn main() {
    let rand_string: String = thread_rng()
        .sample_iter(&amp;Alphanumeric)
        .take(30)
        .collect();

    println!(&quot;{}&quot;, rand_string);
}
</code></pre></pre>
<p><a name="ex-rand-choose"></a></p>
<a class="header" href="print.html#create-random-passwords-from-a-set-of-user-defined-characters" id="create-random-passwords-from-a-set-of-user-defined-characters"><h2>Create random passwords from a set of user-defined characters</h2></a>
<p><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></p>
<p>Randomly generates a string of given length ASCII characters with custom user-defined bytestring, with <a href="https://docs.rs/rand/*/rand/trait.Rng.html#method.choose"><code>choose</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use rand::{thread_rng, Rng};

fn main() {
    const CHARSET: &amp;[u8] =  b&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ\
    abcdefghijklmnopqrstuvwxyz\
    0123456789)(*&amp;^%$#@!~&quot;;

    let mut rng = thread_rng();
    let password: Option&lt;String&gt; = (0..30)
        .map(|_| Some(*rng.choose(CHARSET)? as char))
        .collect();

    println!(&quot;{:?}&quot;, password);
}
</code></pre></pre>
<p><a name="ex-parse-subprocess-output"></a></p>
<a class="header" href="print.html#run-an-external-command-and-process-stdout" id="run-an-external-command-and-process-stdout"><h2>Run an external command and process stdout</h2></a>
<p><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></p>
<p>Runs <code>git log --oneline</code> as an external <a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>Command</code></a> and inspects its <a href="https://doc.rust-lang.org/std/process/struct.Output.html"><code>Output</code></a>
using <a href="https://doc.rust-lang.org/regex/*/regex/struct.Regex.html"><code>Regex</code></a> to get the hash and message of the last 5 commits.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate regex;

use std::process::Command;
use regex::Regex;
#
# error_chain!{
#     foreign_links {
#         Io(std::io::Error);
#         Regex(regex::Error);
#         Utf8(std::string::FromUtf8Error);
#     }
# }

#[derive(PartialEq, Default, Clone, Debug)]
struct Commit {
    hash: String,
    message: String,
}

fn run() -&gt; Result&lt;()&gt; {
    let output = Command::new(&quot;git&quot;).arg(&quot;log&quot;).arg(&quot;--oneline&quot;).output()?;

    if !output.status.success() {
        bail!(&quot;Command executed with failing error code&quot;);
    }

    let pattern = Regex::new(r&quot;(?x)
                               ([0-9a-fA-F]+) # commit hash
                               (.*)           # The commit message&quot;)?;

    String::from_utf8(output.stdout)?
        .lines()
        .filter_map(|line| pattern.captures(line))
        .map(|cap| {
                 Commit {
                     hash: cap[1].to_string(),
                     message: cap[2].trim().to_string(),
                 }
             })
        .take(5)
        .for_each(|x| println!(&quot;{:?}&quot;, x));

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-parse-subprocess-input"></a></p>
<a class="header" href="print.html#run-an-external-command-passing-it-stdin-and-check-for-an-error-code" id="run-an-external-command-passing-it-stdin-and-check-for-an-error-code"><h2>Run an external command passing it stdin and check for an error code</h2></a>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></p>
<p>Opens the <code>python</code> interpreter using an external <a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>Command</code></a> and passes it a python statement
for execution. <a href="https://doc.rust-lang.org/std/process/struct.Output.html"><code>Output</code></a> of said statement is then parsed.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
#
use std::collections::HashSet;
use std::io::Write;
use std::process::{Command, Stdio};
#
# error_chain!{
#     errors { CmdError }
#     foreign_links {
#         Io(std::io::Error);
#         Utf8(std::string::FromUtf8Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let mut child = Command::new(&quot;python&quot;).stdin(Stdio::piped())
        .stderr(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()?;

    child.stdin
        .as_mut()
        .ok_or(&quot;Child process stdin has not been captured!&quot;)?
        .write_all(b&quot;import this; copyright(); credits(); exit()&quot;)?;

    let output = child.wait_with_output()?;

    if output.status.success() {
        let raw_output = String::from_utf8(output.stdout)?;
        let words = raw_output.split_whitespace()
            .map(|s| s.to_lowercase())
            .collect::&lt;HashSet&lt;_&gt;&gt;();
        println!(&quot;Found {} unique words:&quot;, words.len());
        println!(&quot;{:#?}&quot;, words);
        Ok(())
    } else {
        let err = String::from_utf8(output.stderr)?;
        bail!(&quot;External command failed:\n {}&quot;, err)
    }
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-run-piped-external-commands"></a></p>
<a class="header" href="print.html#run-piped-external-commands" id="run-piped-external-commands"><h2>Run piped external commands</h2></a>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></p>
<p>Shows up to the 10<sup>th</sup> biggest files and subdirectories in
the current working directory. It is equivalent to run: <code>du -ah . | sort -hr | head -n 10</code>.</p>
<p>It spawns Unix processes which are represented as <a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>Command</code></a>s. In
order to capture the output of a child process it is necessary to
create a new <a href="https://doc.rust-lang.org/std/process/struct.Stdio.html"><code>Stdio::piped</code></a> between parent and child.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
#
use std::process::{Command, Stdio};
#
# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#         Utf8(std::string::FromUtf8Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let directory = std::env::current_dir()?;
    let du_output = Command::new(&quot;du&quot;)
        .arg(&quot;-ah&quot;)
        .arg(&amp;directory)
        .stdout(Stdio::piped())
        .spawn()?
        .stdout
        .ok_or_else(|| &quot;Could not capture `du` standard output.&quot;)?;

    let sort_output = Command::new(&quot;sort&quot;)
        .arg(&quot;-hr&quot;)
        .stdin(du_output)
        .stdout(Stdio::piped())
        .spawn()?
        .stdout
        .ok_or_else(|| &quot;Could not capture `sort` standard output.&quot;)?;

    let head_output = Command::new(&quot;head&quot;)
        .args(&amp;[&quot;-n&quot;, &quot;10&quot;])
        .stdin(sort_output)
        .stdout(Stdio::piped())
        .spawn()?
        .wait_with_output()?;

    println!(
        &quot;Top 10 biggest files and directories in '{}':\n{}&quot;,
        directory.display(),
        String::from_utf8(head_output.stdout)?
    );

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-redirect-stdout-stderr-same-file"></a></p>
<a class="header" href="print.html#redirect-both-stdout-and-stderr-of-child-process-to-the-same-file" id="redirect-both-stdout-and-stderr-of-child-process-to-the-same-file"><h2>Redirect both stdout and stderr of child process to the same file</h2></a>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></p>
<p>Spawns a child process and redirects <code>stdout</code> and <code>stderr</code> to the same
file. It follows the same idea as <a href="print.html#ex-run-piped-external-commands">run piped external
commands</a>, however <a href="https://doc.rust-lang.org/std/process/struct.Stdio.html"><code>process::Stdio</code></a>
will write to the provided files and beforehand, <a href="https://doc.rust-lang.org/std/fs/struct.File.html#method.try_clone"><code>File::try_clone</code></a>
is used to reference the same file handle for <code>stdout</code> and
<code>stderr</code>. It will ensure that both handles write with the same cursor
position.</p>
<p>The below recipe is equivalent to run the Unix shell command <code>ls . oops &gt;out.txt 2&gt;&amp;1</code>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
#
use std::fs::File;
use std::process::{Command, Stdio};

# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#     }
# }
#
fn run() -&gt; Result&lt;()&gt; {
    let outputs = File::create(&quot;out.txt&quot;)?;
    let errors = outputs.try_clone()?;

    Command::new(&quot;ls&quot;)
        .args(&amp;[&quot;.&quot;, &quot;oops&quot;])
        .stdout(Stdio::from(outputs))
        .stderr(Stdio::from(errors))
        .spawn()?
        .wait_with_output()?;

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-continuous-process-output"></a></p>
<a class="header" href="print.html#continuously-process-child-process-outputs" id="continuously-process-child-process-outputs"><h2>Continuously process child process' outputs</h2></a>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></p>
<p>In <a href="print.html#ex-parse-subprocess-output">Run an external command and process stdout</a>,
processing doesn't start until external <a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>Command</code></a> is finished.
The recipe below creates a new pipe by calling <a href="https://doc.rust-lang.org/std/process/struct.Stdio.html"><code>Stdio::piped</code></a> and reads
<code>stdout</code> continuously as soon as the <a href="https://doc.rust-lang.org/std/io/struct.BufReader.html"><code>BufReader</code></a> is updated.</p>
<p>The below recipe is equivalent to the Unix shell command
<code>journalctl | grep usb</code>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
#
use std::process::{Command, Stdio};
use std::io::{BufRead, BufReader};

# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#     }
# }
#
fn run() -&gt; Result&lt;()&gt; {
    let stdout = Command::new(&quot;journalctl&quot;)
        .stdout(Stdio::piped())
        .spawn()?
        .stdout
        .ok_or_else(|| &quot;Could not capture standard output.&quot;)?;

    let reader = BufReader::new(stdout);

    reader
        .lines()
        .filter_map(|line| line.ok())
        .filter(|line| line.find(&quot;usb&quot;).is_some())
        .for_each(|line| println!(&quot;{}&quot;, line));

     Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-regex-filter-log"></a></p>
<a class="header" href="print.html#filter-a-log-file-by-matching-multiple-regular-expressions" id="filter-a-log-file-by-matching-multiple-regular-expressions"><h2>Filter a log file by matching multiple regular expressions</h2></a>
<p><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></p>
<p>Reads a file named <code>application.log</code> and only outputs the lines
containing “version X.X.X”, some IP address followed by port 443
(e.g. “192.168.0.1:443”), or a specific warning.</p>
<p>A <a href="https://doc.rust-lang.org/regex/*/regex/struct.RegexSet.html"><code>regex::RegexSet</code></a> is built with <a href="https://doc.rust-lang.org/regex/*/regex/struct.RegexSetBuilder.html"><code>regex::RegexSetBuilder</code></a>.
Since backslashes are very common in regular expressions, using
<a href="https://doc.rust-lang.org/reference/tokens.html#raw-string-literals">raw string literals</a> make them more readable.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate regex;

use std::fs::File;
use std::io::{BufReader, BufRead};
use regex::RegexSetBuilder;

# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#         Regex(regex::Error);
#     }
# }
#
fn run() -&gt; Result&lt;()&gt; {
    let log_path = &quot;application.log&quot;;
    let buffered = BufReader::new(File::open(log_path)?);

    let set = RegexSetBuilder::new(&amp;[
        r#&quot;version &quot;\d\.\d\.\d&quot;&quot;#,
        r#&quot;\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:443&quot;#,
        r#&quot;warning.*timeout expired&quot;#,
    ]).case_insensitive(true)
        .build()?;

    buffered
        .lines()
        .filter_map(|line| line.ok())
        .filter(|line| set.is_match(line.as_str()))
        .for_each(|x| println!(&quot;{}&quot;, x));

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-lazy-constant"></a></p>
<a class="header" href="print.html#declare-lazily-evaluated-constant" id="declare-lazily-evaluated-constant"><h2>Declare lazily evaluated constant</h2></a>
<p><a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> <a href="https://crates.io/categories/caching"><img src="https://badge-cache.kominick.com/badge/caching--x.svg?style=social" alt="cat-caching-badge" /></a> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a></p>
<p>Declares a lazily evaluated constant <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a>. The <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> will
be evaluated once and stored behind a global static reference.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate lazy_static;

use std::collections::HashMap;

lazy_static! {
    static ref PRIVILEGES: HashMap&lt;&amp;'static str, Vec&lt;&amp;'static str&gt;&gt; = {
        let mut map = HashMap::new();
        map.insert(&quot;James&quot;, vec![&quot;user&quot;, &quot;admin&quot;]);
        map.insert(&quot;Jim&quot;, vec![&quot;user&quot;]);
        map
    };
}

fn show_access(name: &amp;str) {
    let access = PRIVILEGES.get(name);
    println!(&quot;{}: {:?}&quot;, name, access);
}

fn main() {
    let access = PRIVILEGES.get(&quot;James&quot;);
    println!(&quot;James: {:?}&quot;, access);

    show_access(&quot;Jim&quot;);
}
</code></pre></pre>
<p><a name="ex-global-mut-state"></a></p>
<a class="header" href="print.html#maintain-global-mutable-state" id="maintain-global-mutable-state"><h2>Maintain global mutable state</h2></a>
<p><a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a></p>
<p>Declares some global state using <a href="https://docs.rs/lazy_static/">lazy_static</a>. Since <a href="https://docs.rs/lazy_static/">lazy_static</a>
creates a globally available <code>static ref</code> we also need to wrap our state
in a <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> to allow mutation (also see <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a>). The <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> ensures
the state cannot be simultaneously accessed by multiple threads, preventing
race conditions. A <a href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html"><code>MutexGuard</code></a> must be acquired to read or mutate the
value stored in a <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate lazy_static;

use std::sync::Mutex;
#
# error_chain!{ }

lazy_static! {
    static ref FRUIT: Mutex&lt;Vec&lt;String&gt;&gt; = Mutex::new(Vec::new());
}

fn insert(fruit: &amp;str) -&gt; Result&lt;()&gt; {
    // acquire exclusive access
    let mut db = FRUIT.lock().map_err(|_| &quot;Failed to acquire MutexGuard&quot;)?;
    db.push(fruit.to_string());
    Ok(())
    // release exclusive access
}

fn run() -&gt; Result&lt;()&gt; {
    insert(&quot;apple&quot;)?;
    insert(&quot;orange&quot;)?;
    insert(&quot;peach&quot;)?;
    {
        // acquire access
        let db = FRUIT.lock().map_err(|_| &quot;Failed to acquire MutexGuard&quot;)?;

        db.iter().enumerate().for_each(|(i, item)| println!(&quot;{}: {}&quot;, i, item));
        // release access
    }
    insert(&quot;grape&quot;)?;
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-verify-extract-email"></a></p>
<a class="header" href="print.html#verify-and-extract-login-from-an-email-address" id="verify-and-extract-login-from-an-email-address"><h2>Verify and extract login from an email address</h2></a>
<p><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></p>
<p>Validates that an email address is formatted correctly, and extracts everything
before the @ symbol.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate lazy_static;
extern crate regex;

use regex::Regex;

fn extract_login(input: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    lazy_static! {
        static ref RE: Regex = Regex::new(r&quot;(?x)
            ^(?P&lt;login&gt;[^@\s]+)@
            ([[:word:]]+\.)*
            [[:word:]]+$
            &quot;).unwrap();
    }
    RE.captures(input).and_then(|cap| {
        cap.name(&quot;login&quot;).map(|login| login.as_str())
    })
}

fn main() {
    assert_eq!(extract_login(r&quot;I❤email@example.com&quot;), Some(r&quot;I❤email&quot;));
    assert_eq!(
        extract_login(r&quot;sdf+sdsfsd.as.sdsd@jhkk.d.rl&quot;),
        Some(r&quot;sdf+sdsfsd.as.sdsd&quot;)
    );
    assert_eq!(extract_login(r&quot;More@Than@One@at.com&quot;), None);
    assert_eq!(extract_login(r&quot;Not an email@email&quot;), None);
}
</code></pre></pre>
<p><a name="ex-extract-hashtags"></a></p>
<a class="header" href="print.html#extract-a-list-of-unique-hashtags-from-a-text" id="extract-a-list-of-unique-hashtags-from-a-text"><h2>Extract a list of unique #Hashtags from a text</h2></a>
<p><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></p>
<p>Extracts a sorted and deduplicated list of hashtags from a text.</p>
<p>The hashtag regex given here only catches Latin hashtags that start with a letter. The complete <a href="https://github.com/twitter/twitter-text/blob/c9fc09782efe59af4ee82855768cfaf36273e170/java/src/com/twitter/Regex.java#L255">twitter hashtag regex</a> is much more complicated.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate regex;
#[macro_use]
extern crate lazy_static;

use regex::Regex;
use std::collections::HashSet;

/// Note: A HashSet does not contain duplicate values.
fn extract_hashtags(text: &amp;str) -&gt; HashSet&lt;&amp;str&gt; {
    lazy_static! {
        static ref HASHTAG_REGEX : Regex = Regex::new(
                r&quot;\#[a-zA-Z][0-9a-zA-Z_]*&quot;
            ).unwrap();
    }
    HASHTAG_REGEX.find_iter(text).map(|mat| mat.as_str()).collect()
}

fn main() {
    let tweet = &quot;Hey #world, I just got my new #dog, say hello to Till. #dog #forever #2 #_ &quot;;
    let tags = extract_hashtags(tweet);
    assert!(tags.contains(&quot;#dog&quot;) &amp;&amp; tags.contains(&quot;#forever&quot;) &amp;&amp; tags.contains(&quot;#world&quot;));
    assert_eq!(tags.len(), 3);
}
</code></pre></pre>
<p><a name="ex-regex-replace-named"></a></p>
<a class="header" href="print.html#replace-all-occurrences-of-one-text-pattern-with-another-pattern" id="replace-all-occurrences-of-one-text-pattern-with-another-pattern"><h2>Replace all occurrences of one text pattern with another pattern.</h2></a>
<p><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></p>
<p>Replaces all occurrences of the standard ISO 8601 <em>YYYY-MM-DD</em> date pattern
with the equivalent American English date with slashes; for example <code>2013-01-15</code> becomes <code>01/15/2013</code>.</p>
<p>The method <a href="https://docs.rs/regex/*/regex/struct.Regex.html#method.replace_all"><code>Regex::replace_all</code></a> replaces all occurrences of the whole regex. The
<code>Replacer</code> trait helps to figure out the replacement string. This trait is implemented
for <code>&amp;str</code> and allows to use variables like <code>$abcde</code> to refer to corresponding named capture groups
<code>(?P&lt;abcde&gt;REGEX)</code> from the search regex. See the <a href="https://docs.rs/regex/*/regex/struct.Regex.html#replacement-string-syntax">replacement string syntax</a> for examples
and information about escaping.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate regex;
#[macro_use]
extern crate lazy_static;

use std::borrow::Cow;
use regex::Regex;

fn reformat_dates(before: &amp;str) -&gt; Cow&lt;str&gt; {
    lazy_static! {
        static ref ISO8601_DATE_REGEX : Regex = Regex::new(
            r&quot;(?P&lt;y&gt;\d{4})-(?P&lt;m&gt;\d{2})-(?P&lt;d&gt;\d{2})&quot;
            ).unwrap();
    }
    ISO8601_DATE_REGEX.replace_all(before, &quot;$m/$d/$y&quot;)
}

fn main() {
    let before = &quot;2012-03-14, 2013-01-15 and 2014-07-05&quot;;
    let after = reformat_dates(before);
    assert_eq!(after, &quot;03/14/2012, 01/15/2013 and 07/05/2014&quot;);
}
</code></pre></pre>
<p><a name="ex-phone"></a></p>
<a class="header" href="print.html#extract-phone-numbers-from-text" id="extract-phone-numbers-from-text"><h2>Extract phone numbers from text</h2></a>
<p><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></p>
<p>Processes a string of text using <a href="https://doc.rust-lang.org/regex/*/regex/struct.Regex.html#method.captures_iter"><code>Regex::captures_iter</code></a> to capture multiple
phone numbers.  The example here is for US convention phone numbers.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate regex;

use regex::Regex;
use std::fmt;
#
# error_chain!{
#     foreign_links {
#         Regex(regex::Error);
#         Io(std::io::Error);
#     }
# }

struct PhoneNumber&lt;'a&gt; {
    area: &amp;'a str,
    exchange: &amp;'a str,
    subscriber: &amp;'a str,
}

// Allows printing phone numbers based on country convention.
impl&lt;'a&gt; fmt::Display for PhoneNumber&lt;'a&gt; {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;1 ({}) {}-{}&quot;, self.area, self.exchange, self.subscriber)
    }
}

fn run() -&gt; Result&lt;()&gt; {
    let phone_text = &quot;
    +1 505 881 9292 (v) +1 505 778 2212 (c) +1 505 881 9297 (f)
    (202) 991 9534
    Alex 5553920011
    1 (800) 233-2010
    1.299.339.1020&quot;;

    let re = Regex::new(
        r#&quot;(?x)
          (?:\+?1)?                       # Country Code Optional
          [\s\.]?
          (([2-9]\d{2})|\(([2-9]\d{2})\)) # Area Code
          [\s\.\-]?
          ([2-9]\d{2})                    # Exchange Code
          [\s\.\-]?
          (\d{4})                         # Subscriber Number&quot;#,
    )?;

    let phone_numbers = re.captures_iter(phone_text).filter_map(|cap| {
        // Area code populates either capture group 2 or 3.
        // Group 1 contains optional parenthesis.
        let groups = (cap.get(2).or(cap.get(3)), cap.get(4), cap.get(5));
        match groups {
            (Some(area), Some(ext), Some(sub)) =&gt; Some(PhoneNumber {
                area: area.as_str(),
                exchange: ext.as_str(),
                subscriber: sub.as_str(),
            }),
            _ =&gt; None,
        }
    });

    assert_eq!(
        phone_numbers.map(|m| m.to_string()).collect::&lt;Vec&lt;_&gt;&gt;(),
        vec![
            &quot;1 (505) 881-9292&quot;,
            &quot;1 (505) 778-2212&quot;,
            &quot;1 (505) 881-9297&quot;,
            &quot;1 (202) 991-9534&quot;,
            &quot;1 (555) 392-0011&quot;,
            &quot;1 (800) 233-2010&quot;,
            &quot;1 (299) 339-1020&quot;,
        ]
    );

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-sha-digest"></a></p>
<a class="header" href="print.html#calculate-the-sha-256-digest-of-a-file" id="calculate-the-sha-256-digest-of-a-file"><h2>Calculate the SHA-256 digest of a file</h2></a>
<p><a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a> <a href="https://docs.rs/data-encoding/"><img src="https://badge-cache.kominick.com/crates/v/data-encoding.svg?label=data-encoding" alt="data-encoding-badge" /></a> <a href="https://crates.io/categories/cryptography"><img src="https://badge-cache.kominick.com/badge/cryptography--x.svg?style=social" alt="cat-cryptography-badge" /></a></p>
<p>Writes some data to a file, then calculates the SHA-256 <a href="https://briansmith.org/rustdoc/ring/digest/struct.Digest.html"><code>digest::Digest</code></a> of
the file's contents using <a href="https://briansmith.org/rustdoc/ring/digest/struct.Context.html"><code>digest::Context</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate data_encoding;
extern crate ring;

use data_encoding::HEXUPPER;
use ring::digest::{Context, Digest, SHA256};
use std::fs::File;
use std::io::{BufReader, Read, Write};
#
# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#         Decode(data_encoding::DecodeError);
#     }
# }

fn sha256_digest&lt;R: Read&gt;(mut reader: R) -&gt; Result&lt;Digest&gt; {
    let mut context = Context::new(&amp;SHA256);
    let mut buffer = [0; 1024];

    loop {
        let count = reader.read(&amp;mut buffer)?;
        if count == 0 {
            break;
        }
        context.update(&amp;buffer[..count]);
    }

    Ok(context.finish())
}

fn run() -&gt; Result&lt;()&gt; {
    let path = &quot;file.txt&quot;;

    let mut output = File::create(path)?;
    write!(output, &quot;We will generate a digest of this text&quot;)?;

    let input = File::open(path)?;
    let reader = BufReader::new(input);
    let digest = sha256_digest(reader)?;

    // digest.as_ref() provides the digest as a byte slice: &amp;[u8]
    println!(&quot;SHA-256 digest is {}&quot;, HEXUPPER.encode(digest.as_ref()));

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-hmac"></a></p>
<a class="header" href="print.html#sign-and-verify-a-message-with-hmac-digest" id="sign-and-verify-a-message-with-hmac-digest"><h2>Sign and verify a message with HMAC digest</h2></a>
<p><a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a> <a href="https://crates.io/categories/cryptography"><img src="https://badge-cache.kominick.com/badge/cryptography--x.svg?style=social" alt="cat-cryptography-badge" /></a></p>
<p>Uses <a href="https://briansmith.org/rustdoc/ring/hmac/"><code>ring::hmac</code></a> to creates a <a href="https://briansmith.org/rustdoc/ring/hmac/struct.Signature.html"><code>hmac::Signature</code></a> of a string then verifies the signature is correct.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate ring;
#
# error_chain! {
#     foreign_links {
#         Ring(ring::error::Unspecified);
#     }
# }

use ring::{digest, hmac, rand};
use ring::rand::SecureRandom;

fn run() -&gt; Result&lt;()&gt; {
    let mut key_value = [0u8; 48];
    let rng = rand::SystemRandom::new();
    rng.fill(&amp;mut key_value)?;
    let key = hmac::SigningKey::new(&amp;digest::SHA256, &amp;key_value);

    let message = &quot;Legitimate and important message.&quot;;
    let signature = hmac::sign(&amp;key, message.as_bytes());
    hmac::verify_with_own_key(&amp;key, message.as_bytes(), signature.as_ref())?;

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-pbkdf2"></a></p>
<a class="header" href="print.html#salt-and-hash-a-password-with-pbkdf2" id="salt-and-hash-a-password-with-pbkdf2"><h2>Salt and hash a password with PBKDF2</h2></a>
<p><a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a> <a href="https://docs.rs/data-encoding/"><img src="https://badge-cache.kominick.com/crates/v/data-encoding.svg?label=data-encoding" alt="data-encoding-badge" /></a> <a href="https://crates.io/categories/cryptography"><img src="https://badge-cache.kominick.com/badge/cryptography--x.svg?style=social" alt="cat-cryptography-badge" /></a></p>
<p>Uses <a href="https://briansmith.org/rustdoc/ring/pbkdf2/index.html"><code>ring::pbkdf2</code></a> to hash a salted password using the PBKDF2 key derivation
function <a href="https://briansmith.org/rustdoc/ring/pbkdf2/fn.derive.html"><code>pbkdf2::derive</code></a> and then verifies the hash is correct with
<a href="https://briansmith.org/rustdoc/ring/pbkdf2/fn.verify.html"><code>pbkdf2::verify</code></a>. The salt is generated using
<a href="https://briansmith.org/rustdoc/ring/rand/trait.SecureRandom.html#tymethod.fill"><code>SecureRandom::fill</code></a>, which fills the salt byte array with
securely generated random numbers.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate data_encoding;
extern crate ring;
#
# error_chain! {
#   foreign_links {
#     Ring(ring::error::Unspecified);
#   }
# }

use data_encoding::HEXUPPER;
use ring::{digest, pbkdf2, rand};
use ring::rand::SecureRandom;

fn run() -&gt; Result&lt;()&gt; {
  const CREDENTIAL_LEN: usize = digest::SHA512_OUTPUT_LEN;
  const N_ITER: u32 = 100_000;
  let rng = rand::SystemRandom::new();

  // Generate salt
  let mut salt = [0u8; CREDENTIAL_LEN];
  rng.fill(&amp;mut salt)?;

  // Hash password
  let password = &quot;Guess Me If You Can!&quot;;
  let mut pbkdf2_hash = [0u8; CREDENTIAL_LEN];
  pbkdf2::derive(
      &amp;digest::SHA512,
      N_ITER,
      &amp;salt,
      password.as_bytes(),
      &amp;mut pbkdf2_hash,
  );
  println!(&quot;Salt: {}&quot;, HEXUPPER.encode(&amp;salt));
  println!(&quot;PBKDF2 hash: {}&quot;, HEXUPPER.encode(&amp;pbkdf2_hash));

  // Verify hash with correct password and wrong password
  let should_succeed = pbkdf2::verify(
      &amp;digest::SHA512,
      N_ITER,
      &amp;salt,
      password.as_bytes(),
      &amp;pbkdf2_hash,
  );
  let wrong_password = &quot;Definitely not the correct password&quot;;
  let should_fail = pbkdf2::verify(
      &amp;digest::SHA512,
      N_ITER,
      &amp;salt,
      wrong_password.as_bytes(),
      &amp;pbkdf2_hash,
  );

  assert!(should_succeed.is_ok());
  assert!(!should_fail.is_ok());

  Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-bitflags"></a></p>
<a class="header" href="print.html#define-and-operate-on-a-type-represented-as-a-bitfield" id="define-and-operate-on-a-type-represented-as-a-bitfield"><h2>Define and operate on a type represented as a bitfield</h2></a>
<p><a href="https://docs.rs/bitflags/"><img src="https://badge-cache.kominick.com/crates/v/bitflags.svg?label=bitflags" alt="bitflags-badge" /></a> <a href="https://crates.io/categories/no-std"><img src="https://badge-cache.kominick.com/badge/no_std--x.svg?style=social" alt="cat-no-std-badge" /></a></p>
<p>Creates typesafe bitfield type <code>MyFlags</code> with help of <a href="https://docs.rs/bitflags/*/bitflags/macro.bitflags.html"><code>bitflags!</code></a> macro
and implements elementary <code>clear</code> operation as well as <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a> trait for it.
Subsequently, shows basic bitwise operations and formatting.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate bitflags;

use std::fmt;

bitflags! {
    struct MyFlags: u32 {
        const FLAG_A       = 0b00000001;
        const FLAG_B       = 0b00000010;
        const FLAG_C       = 0b00000100;
        const FLAG_ABC     = Self::FLAG_A.bits
                           | Self::FLAG_B.bits
                           | Self::FLAG_C.bits;
    }
}

impl MyFlags {
    pub fn clear(&amp;mut self) -&gt; &amp;mut MyFlags {
        self.bits = 0;  // The `bits` field can be accessed from within the
                        // same module where the `bitflags!` macro was invoked.
        self
    }
}

impl fmt::Display for MyFlags {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{:032b}&quot;, self.bits)
    }
}

fn main() {
    let e1 = MyFlags::FLAG_A | MyFlags::FLAG_C;
    let e2 = MyFlags::FLAG_B | MyFlags::FLAG_C;
    assert_eq!((e1 | e2), MyFlags::FLAG_ABC);   // union
    assert_eq!((e1 &amp; e2), MyFlags::FLAG_C);     // intersection
    assert_eq!((e1 - e2), MyFlags::FLAG_A);     // set difference
    assert_eq!(!e2, MyFlags::FLAG_A);           // set complement

    let mut flags = MyFlags::FLAG_ABC;
    assert_eq!(format!(&quot;{}&quot;, flags), &quot;00000000000000000000000000000111&quot;);
    assert_eq!(format!(&quot;{}&quot;, flags.clear()), &quot;00000000000000000000000000000000&quot;);
    // Debug trait is automatically derived for the MyFlags through `bitflags!`
    assert_eq!(format!(&quot;{:?}&quot;, MyFlags::FLAG_B), &quot;FLAG_B&quot;);
    assert_eq!(format!(&quot;{:?}&quot;, MyFlags::FLAG_A | MyFlags::FLAG_B), &quot;FLAG_A | FLAG_B&quot;);
}
</code></pre></pre>
<p><a name="ex-random-file-access"></a></p>
<a class="header" href="print.html#access-a-file-randomly-using-a-memory-map" id="access-a-file-randomly-using-a-memory-map"><h2>Access a file randomly using a memory map</h2></a>
<p><a href="https://docs.rs/memmap/"><img src="https://badge-cache.kominick.com/crates/v/memmap.svg?label=memmap" alt="memmap-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Creates a memory map of a file using <a href="https://docs.rs/memmap/">memmap</a> and simulates some non-sequential
reads from the file. Using a memory map means you just index into a slice rather
than dealing with <a href="https://doc.rust-lang.org/std/fs/struct.File.html#method.seek"><code>seek</code></a>ing around in a File.</p>
<p>The <a href="https://docs.rs/memmap/*/memmap/struct.Mmap.html#method.map"><code>Mmap::map</code></a> function is only safe if we can guarantee that the file
behind the memory map is not being modified at the same time by another process,
as this would be a <a href="https://en.wikipedia.org/wiki/Race_condition#File_systems">race condition</a>.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate memmap;

use memmap::Mmap;
# use std::fs::File;
# use std::io::Write;
#
# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
#     write!(File::create(&quot;content.txt&quot;)?, &quot;My hovercraft is full of eels!&quot;)?;
#
    let file = File::open(&quot;content.txt&quot;)?;
    let map = unsafe { Mmap::map(&amp;file)? };

    let random_indexes = [0, 1, 2, 19, 22, 10, 11, 29];
    assert_eq!(&amp;map[3..13], b&quot;hovercraft&quot;);
    // I'm using an iterator here to change indexes to bytes
    let random_bytes: Vec&lt;u8&gt; = random_indexes.iter()
        .map(|&amp;idx| map[idx])
        .collect();
    assert_eq!(&amp;random_bytes[..], b&quot;My loaf!&quot;);
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-check-cpu-cores"></a></p>
<a class="header" href="print.html#check-number-of-logical-cpu-cores" id="check-number-of-logical-cpu-cores"><h2>Check number of logical cpu cores</h2></a>
<p><a href="https://docs.rs/num_cpus/"><img src="https://badge-cache.kominick.com/crates/v/num_cpus.svg?label=num_cpus" alt="num_cpus-badge" /></a> <a href="https://crates.io/categories/hardware-support"><img src="https://badge-cache.kominick.com/badge/hardware_support--x.svg?style=social" alt="cat-hardware-support-badge" /></a></p>
<p>Shows the number of logical cpu cores in current machine using <a href="https://docs.rs/num_cpus/*/num_cpus/fn.get.html"><code>num_cpus::get</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate num_cpus;

fn main() {
    println!(&quot;Number of logical cores is {}&quot;, num_cpus::get());
}
</code></pre></pre>
<p><a name="ex-error-chain-simple-error-handling"></a></p>
<a class="header" href="print.html#handle-errors-correctly-in-main" id="handle-errors-correctly-in-main"><h2>Handle errors correctly in main</h2></a>
<p><a href="https://docs.rs/error-chain/"><img src="https://badge-cache.kominick.com/crates/v/error-chain.svg?label=error-chain" alt="error-chain-badge" /></a> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a></p>
<p>Handles error that occur when trying to open a file that does not
exist. It is achieved by using <a href="https://docs.rs/error-chain/">error-chain</a>, a library that takes
care of a lot of boilerplate code needed in order to <a href="https://doc.rust-lang.org/book/second-edition/ch09-00-error-handling.html">handle errors in
Rust</a>.</p>
<p><code>Io(std::io::Error)</code> inside <a href="https://docs.rs/error-chain/*/error_chain/#foreign-links"><code>foreign_links</code></a> allows automatic
conversion from <a href="https://doc.rust-lang.org/std/io/struct.Error.html"><code>std::io::Error</code></a> into <a href="https://docs.rs/error-chain/*/error_chain/macro.error_chain.html"><code>error_chain!</code></a> defined type
implementing the <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a> trait.</p>
<p>The below recipe will tell how long the system has been running by
opening the Unix file <code>/proc/uptime</code> and parse the content to get the
first number. Returns uptime unless there is an error.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate error_chain;

use std::fs::File;
use std::io::Read;

error_chain!{
    foreign_links {
        Io(std::io::Error);
        ParseInt(::std::num::ParseIntError);
    }
}

fn read_uptime() -&gt; Result&lt;u64&gt; {
    let mut uptime = String::new();
    File::open(&quot;/proc/uptime&quot;)?.read_to_string(&amp;mut uptime)?;

    Ok(uptime
        .split('.')
        .next()
        .ok_or(&quot;Cannot parse uptime data&quot;)?
        .parse()?)
}

fn main() {
    match read_uptime() {
        Ok(uptime) =&gt; println!(&quot;uptime: {} seconds&quot;, uptime),
        Err(err) =&gt; eprintln!(&quot;error: {}&quot;, err),
    };
}
</code></pre></pre>
<p><a name="ex-error-chain-avoid-discarding"></a></p>
<a class="header" href="print.html#avoid-discarding-errors-during-error-conversions" id="avoid-discarding-errors-during-error-conversions"><h2>Avoid discarding errors during error conversions</h2></a>
<p><a href="https://docs.rs/error-chain/"><img src="https://badge-cache.kominick.com/crates/v/error-chain.svg?label=error-chain" alt="error-chain-badge" /></a> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a></p>
<p><a href="https://docs.rs/error-chain/*/error_chain/#matching-errors">Matching</a> on different error types returned by a function is possible
and relatively compact with <a href="https://docs.rs/error-chain/">error-chain</a> crate. To do so,
<a href="https://docs.rs/error-chain/*/error_chain/example_generated/enum.ErrorKind.html"><code>ErrorKind</code></a> is used to determine the error type.</p>
<p>To illustrate the error matching, a random integer generator web
service will be queried via <a href="https://docs.rs/reqwest/">reqwest</a> and then the response will be
parsed. Errors can be generated by the Rust standard library,
<a href="https://docs.rs/reqwest/">reqwest</a> and by the web service. <a href="https://docs.rs/error-chain/*/error_chain/#foreign-links"><code>foreign_links</code></a> are used for well
defined Rust errors. The <code>errors</code> block of the <code>error_chain!</code> macro is
used to create an additional <a href="https://docs.rs/error-chain/*/error_chain/example_generated/enum.ErrorKind.html"><code>ErrorKind</code></a> variant for the web service
error. Finally, a regular <code>match</code> can be used to react differently
according to the raised error.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate error_chain;
extern crate reqwest;

use std::io::Read;

error_chain! {
    foreign_links {
        Io(std::io::Error);
        Reqwest(reqwest::Error);
        ParseIntError(std::num::ParseIntError);
    }

    errors { RandomResponseError(t: String) }
}

fn parse_response(mut response: reqwest::Response) -&gt; Result&lt;u32&gt; {
    let mut body = String::new();
    response.read_to_string(&amp;mut body)?;
    body.pop();
    body.parse::&lt;u32&gt;()
        .chain_err(|| ErrorKind::RandomResponseError(body))
}

fn run() -&gt; Result&lt;()&gt; {
    let url =
        format!(&quot;https://www.random.org/integers/?num=1&amp;min=0&amp;max=10&amp;col=1&amp;base=10&amp;format=plain&quot;);
    let response = reqwest::get(&amp;url)?;
    let random_value: u32 = parse_response(response)?;

    println!(&quot;a random number between 0 and 10: {}&quot;, random_value);

    Ok(())
}

fn main() {
    if let Err(error) = run() {
        match *error.kind() {
            ErrorKind::Io(_) =&gt; println!(&quot;Standard IO error: {:?}&quot;, error),
            ErrorKind::Reqwest(_) =&gt; println!(&quot;Reqwest error: {:?}&quot;, error),
            ErrorKind::ParseIntError(_) =&gt; println!(&quot;Standard parse int error: {:?}&quot;, error),
            ErrorKind::RandomResponseError(_) =&gt; println!(&quot;User defined error: {:?}&quot;, error),
            _ =&gt; println!(&quot;Other error: {:?}&quot;, error),
        }
    }
}
</code></pre></pre>
<p><a name="ex-error-chain-backtrace"></a></p>
<a class="header" href="print.html#obtain-backtrace-of-complex-error-scenarios" id="obtain-backtrace-of-complex-error-scenarios"><h2>Obtain backtrace of complex error scenarios</h2></a>
<p><a href="https://docs.rs/error-chain/"><img src="https://badge-cache.kominick.com/crates/v/error-chain.svg?label=error-chain" alt="error-chain-badge" /></a> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a></p>
<p>This recipe shows how to handle a complex error scenario and then
print a backtrace. It relies on <a href="https://docs.rs/error-chain/*/error_chain/index.html#chaining-errors"><code>chain_err</code></a> to extend errors by
appending new errors. The error stack can be unwinded, thus providing
a better context to understand why an error was raised.</p>
<p>The below recipes attempts to deserialize the value <code>256</code> into a
<code>u8</code>. An error will bubble up from Serde then csv and finally up to the
user code.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate csv;
#[macro_use]
extern crate error_chain;
# #[macro_use]
# extern crate serde_derive;
#
# use std::fmt;
#
# error_chain! {
#     foreign_links {
#         Reader(csv::Error);
#     }
# }

#[derive(Debug, Deserialize)]
struct Rgb {
    red: u8,
    blue: u8,
    green: u8,
}

impl Rgb {
    fn from_reader(csv_data: &amp;[u8]) -&gt; Result&lt;Rgb&gt; {
        let color: Rgb = csv::Reader::from_reader(csv_data)
            .deserialize()
            .nth(0)
            .ok_or(&quot;Cannot deserialize the first CSV record&quot;)?
            .chain_err(|| &quot;Cannot deserialize RGB color&quot;)?;

        Ok(color)
    }
}

# impl fmt::UpperHex for Rgb {
#     fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
#         let hexa = u32::from(self.red) &lt;&lt; 16 | u32::from(self.blue) &lt;&lt; 8 | u32::from(self.green);
#         write!(f, &quot;{:X}&quot;, hexa)
#     }
# }
#
fn run() -&gt; Result&lt;()&gt; {
    let csv = &quot;red,blue,green
102,256,204&quot;;

    let rgb = Rgb::from_reader(csv.as_bytes()).chain_err(|| &quot;Cannot read CSV data&quot;)?;
    println!(&quot;{:?} to hexadecimal #{:X}&quot;, rgb, rgb);

    Ok(())
}

fn main() {
    if let Err(ref errors) = run() {
        eprintln!(&quot;Error level - description&quot;);
        errors
            .iter()
            .enumerate()
            .for_each(|(index, error)| eprintln!(&quot;└&gt; {} - {}&quot;, index, error));

        if let Some(backtrace) = errors.backtrace() {
            eprintln!(&quot;{:?}&quot;, backtrace);
        }
#
#         // In a real use case, errors should handled. For example:
#         // ::std::process::exit(1);
    }
}
</code></pre></pre>
<p>Backtrace error rendered:</p>
<pre><code class="language-text">Error level - description
└&gt; 0 - Cannot read CSV data
└&gt; 1 - Cannot deserialize RGB color
└&gt; 2 - CSV deserialize error: record 1 (line: 2, byte: 15): field 1: number too large to fit in target type
└&gt; 3 - field 1: number too large to fit in target type
</code></pre>
<p>Run the recipe with <code>RUST_BACKTRACE=1</code> to display a detailed <a href="https://docs.rs/error-chain/*/error_chain/trait.ChainedError.html#tymethod.backtrace"><code>backtrace</code></a> associated with this error.</p>
<p><a name="ex-measure-elapsed-time"></a></p>
<a class="header" href="print.html#measure-the-elapsed-time-between-two-code-sections" id="measure-the-elapsed-time-between-two-code-sections"><h2>Measure the elapsed time between two code sections</h2></a>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/time--x.svg?style=social" alt="cat-time-badge" /></a></p>
<p>Measures <a href="https://doc.rust-lang.org/std/time/struct.Instant.html#method.elapsed"><code>time::Instant::elapsed</code></a> since <a href="https://doc.rust-lang.org/std/time/struct.Instant.html#method.now"><code>time::Instant::now</code></a>.</p>
<p>Calling <a href="https://doc.rust-lang.org/std/time/struct.Instant.html#method.elapsed"><code>time::Instant::elapsed</code></a> returns a <a href="https://doc.rust-lang.org/std/time/struct.Duration.html"><code>time::Duration</code></a> that we print at the end of the example.
This method will not mutate or reset the <a href="https://doc.rust-lang.org/std/time/struct.Instant.html"><code>time::Instant</code></a> object.</p>
<pre><pre class="playpen"><code class="language-rust">use std::time::{Duration, Instant};
# use std::thread;
#
# fn expensive_function() {
#     thread::sleep(Duration::from_secs(1));
# }

fn main() {
    let start = Instant::now();
    expensive_function();
    let duration = start.elapsed();

    println!(&quot;Time elapsed in expensive_function() is: {:?}&quot;, duration);
}
</code></pre></pre>
<p><a name="ex-convert-datetime-timezone"></a></p>
<a class="header" href="print.html#convert-a-local-time-to-an-another-utc-timezone-and-vice-versa" id="convert-a-local-time-to-an-another-utc-timezone-and-vice-versa"><h2>Convert a local time to an another UTC timezone and vice versa</h2></a>
<p><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></p>
<p>Gets the local time and displays it using <a href="https://docs.rs/chrono/*/chrono/offset/struct.Local.html#method.now"><code>offset::Local::now</code></a> and then converts it to the UTC standard using the <a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.from_utc"><code>DateTime::from_utc</code></a> struct method. A time is then converted using the <a href="https://docs.rs/chrono/*/chrono/offset/struct.FixedOffset.html"><code>offset::FixedOffset</code></a> struct and the UTC time is then converted to UTC+8 and UTC-2.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate chrono;

use chrono::{DateTime, FixedOffset, Local, Utc};

fn main() {
    let local_time = Local::now();
    let utc_time = DateTime::&lt;Utc&gt;::from_utc(local_time.naive_utc(), Utc);
    let china_timezone = FixedOffset::east(8 * 3600);
    let rio_timezone = FixedOffset::west(2 * 3600);
    println!(&quot;Local time now is {}&quot;, local_time);
    println!(&quot;UTC time now is {}&quot;, utc_time);
    println!(
        &quot;Time in Hong Kong now is {}&quot;,
        utc_time.with_timezone(&amp;china_timezone)
    );
    println!(&quot;Time in Rio de Janeiro now is {}&quot;, utc_time.with_timezone(&amp;rio_timezone));
}
</code></pre></pre>
<p><a name="ex-convert-datetime-timestamp"></a></p>
<a class="header" href="print.html#convert-date-to-unix-timestamp-and-vice-versa" id="convert-date-to-unix-timestamp-and-vice-versa"><h2>Convert date to UNIX timestamp and vice versa</h2></a>
<p><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></p>
<p>Converts a date given by <a href="https://docs.rs/chrono/*/chrono/naive/struct.NaiveDate.html#method.from_ymd"><code>NaiveDate::from_ymd</code></a> and <a href="https://docs.rs/chrono/*/chrono/naive/struct.NaiveTime.html#method.from_hms"><code>NaiveTime::from_hms</code></a>
to <a href="https://en.wikipedia.org/wiki/Unix_time">UNIX timestamp</a> using <a href="https://docs.rs/chrono/*/chrono/naive/struct.NaiveDateTime.html#method.timestamp"><code>NaiveDateTime::timestamp</code></a>.
Then it calculates what was the date after one billion seconds
since January 1, 1970 0:00:00 UTC, using <a href="https://docs.rs/chrono/*/chrono/naive/struct.NaiveDateTime.html#method.from_timestamp"><code>NaiveDateTime::from_timestamp</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate chrono;

use chrono::{NaiveDate, NaiveDateTime};

fn main() {
    let date_time: NaiveDateTime = NaiveDate::from_ymd(2017, 11, 12).and_hms(17, 33, 44);
    println!(
        &quot;Number of seconds between 1970-01-01 00:00:00 and {} is {}.&quot;,
        date_time, date_time.timestamp());

    let date_time_after_a_billion_seconds = NaiveDateTime::from_timestamp(1_000_000_000, 0);
    println!(
        &quot;Date after a billion seconds since 1970-01-01 00:00:00 was {}.&quot;,
        date_time_after_a_billion_seconds);
}
</code></pre></pre>
<p><a name="ex-format-datetime"></a></p>
<a class="header" href="print.html#display-formatted-date-and-time" id="display-formatted-date-and-time"><h2>Display formatted date and time</h2></a>
<p><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></p>
<p>Gets and displays the current time in UTC using <a href="https://docs.rs/chrono/*/chrono/offset/struct.Utc.html#method.now"><code>Utc::now</code></a>. Formats the
current time in the well-known formats <a href="https://www.ietf.org/rfc/rfc2822.txt">RFC 2822</a> using <a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.to_rfc2822"><code>DateTime::to_rfc2822</code></a>
and <a href="https://www.ietf.org/rfc/rfc3339.txt">RFC 3339</a> using <a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.to_rfc3339"><code>DateTime::to_rfc3339</code></a>, and in a custom format using
<a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.format"><code>DateTime::format</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate chrono;
use chrono::{DateTime, Utc};

fn main() {
    let now: DateTime&lt;Utc&gt; = Utc::now();

    println!(&quot;UTC now is: {}&quot;, now);
    println!(&quot;UTC now in RFC 2822 is: {}&quot;, now.to_rfc2822());
    println!(&quot;UTC now in RFC 3339 is: {}&quot;, now.to_rfc3339());
    println!(&quot;UTC now in a custom format is: {}&quot;, now.format(&quot;%a %b %e %T %Y&quot;));
}
</code></pre></pre>
<p><a name="ex-parse-datetime"></a></p>
<a class="header" href="print.html#parse-string-into-datetime-struct" id="parse-string-into-datetime-struct"><h2>Parse string into DateTime struct</h2></a>
<p><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></p>
<p>Parses a <a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html"><code>DateTime</code></a> struct from strings representing the well-known formats
<a href="https://www.ietf.org/rfc/rfc2822.txt">RFC 2822</a>, <a href="https://www.ietf.org/rfc/rfc3339.txt">RFC 3339</a>, and a custom format, using
<a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.parse_from_rfc2822"><code>DateTime::parse_from_rfc2822</code></a>, <a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.parse_from_rfc3339"><code>DateTime::parse_from_rfc3339</code></a>, and
<a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.parse_from_str"><code>DateTime::parse_from_str</code></a> respectively.</p>
<p>Escape sequences that are available for the <a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.parse_from_str"><code>DateTime::parse_from_str</code></a> can be
found at <a href="https://docs.rs/chrono/*/chrono/format/strftime/index.html"><code>chrono::format::strftime</code></a>. Note that the <a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.parse_from_str"><code>DateTime::parse_from_str</code></a>
requires that such a DateTime struct can be created that it uniquely
identifies a date and a time. For parsing dates and times without timezones use
<a href="https://docs.rs/chrono/*/chrono/naive/struct.NaiveDate.html"><code>NaiveDate</code></a>, <a href="https://docs.rs/chrono/*/chrono/naive/struct.NaiveTime.html"><code>NaiveTime</code></a>, and <a href="https://docs.rs/chrono/*/chrono/naive/struct.NaiveDateTime.html"><code>NaiveDateTime</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate chrono;
# #[macro_use]
# extern crate error_chain;
#
use chrono::{DateTime, NaiveDate, NaiveDateTime, NaiveTime};
#
# error_chain! {
#     foreign_links {
#         DateParse(chrono::format::ParseError);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let rfc2822 = DateTime::parse_from_rfc2822(&quot;Tue, 1 Jul 2003 10:52:37 +0200&quot;)?;
    println!(&quot;{}&quot;, rfc2822);

    let rfc3339 = DateTime::parse_from_rfc3339(&quot;1996-12-19T16:39:57-08:00&quot;)?;
    println!(&quot;{}&quot;, rfc3339);

    let custom = DateTime::parse_from_str(&quot;5.8.1994 8:00 am +0000&quot;, &quot;%d.%m.%Y %H:%M %P %z&quot;)?;
    println!(&quot;{}&quot;, custom);

    let time_only = NaiveTime::parse_from_str(&quot;23:56:04&quot;, &quot;%H:%M:%S&quot;)?;
    println!(&quot;{}&quot;, time_only);

    let date_only = NaiveDate::parse_from_str(&quot;2015-09-05&quot;, &quot;%Y-%m-%d&quot;)?;
    println!(&quot;{}&quot;, date_only);

    let no_timezone = NaiveDateTime::parse_from_str(&quot;2015-09-05 23:56:04&quot;, &quot;%Y-%m-%d %H:%M:%S&quot;)?;
    println!(&quot;{}&quot;, no_timezone);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-datetime-arithmetic"></a></p>
<a class="header" href="print.html#perform-checked-date-and-time-calculations" id="perform-checked-date-and-time-calculations"><h2>Perform checked date and time calculations</h2></a>
<p><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></p>
<p>Calculates and displays the date and time two weeks from now using
<a href="https://docs.rs/chrono/*/chrono/struct.Date.html#method.checked_add_signed"><code>DateTime::checked_add_signed</code></a> and the date of the day before that using
<a href="https://docs.rs/chrono/*/chrono/struct.Date.html#method.checked_sub_signed"><code>DateTime::checked_sub_signed</code></a>. The methods return None if the date and time
cannot be calculated.</p>
<p>Escape sequences that are available for the
<a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.format"><code>DateTime::format</code></a> can be found at <a href="https://docs.rs/chrono/*/chrono/format/strftime/index.html"><code>chrono::format::strftime</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate chrono;
use chrono::{DateTime, Duration, Utc};

fn day_earlier(date_time: DateTime&lt;Utc&gt;) -&gt; Option&lt;DateTime&lt;Utc&gt;&gt; {
    date_time.checked_sub_signed(Duration::days(1))
}

fn main() {
    let now = Utc::now();
    println!(&quot;{}&quot;, now);

    let almost_three_weeks_from_now = now.checked_add_signed(Duration::weeks(2))
            .and_then(|in_2weeks| in_2weeks.checked_add_signed(Duration::weeks(1)))
            .and_then(day_earlier);

    match almost_three_weeks_from_now {
        Some(x) =&gt; println!(&quot;{}&quot;, x),
        None =&gt; eprintln!(&quot;Almost three weeks from now overflows!&quot;),
    }

    match now.checked_add_signed(Duration::max_value()) {
        Some(x) =&gt; println!(&quot;{}&quot;, x),
        None =&gt; eprintln!(&quot;We can't use chrono to tell the time for the Solar System to complete more than one full orbit around the galactic center.&quot;),
    }
}
</code></pre></pre>
<p><a name="ex-examine-date-and-time"></a></p>
<a class="header" href="print.html#examine-the-date-and-time" id="examine-the-date-and-time"><h2>Examine the date and time</h2></a>
<p><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></p>
<p>Gets the current UTC <a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html"><code>DateTime</code></a> and its hour/minute/second via <a href="https://docs.rs/chrono/*/chrono/trait.Timelike.html"><code>Timelike</code></a>
and its year/month/day/weekday via <a href="https://docs.rs/chrono/*/chrono/trait.Datelike.html"><code>Datelike</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate chrono;
use chrono::{Datelike, Timelike, Utc};

fn main() {
    let now = Utc::now();

    let (is_pm, hour) = now.hour12();
    println!(
        &quot;The current UTC time is {:02}:{:02}:{:02} {}&quot;,
        hour,
        now.minute(),
        now.second(),
        if is_pm { &quot;PM&quot; } else { &quot;AM&quot; }
    );
    println!(
        &quot;And there have been {} seconds since midnight&quot;,
        now.num_seconds_from_midnight()
    );

    let (is_common_era, year) = now.year_ce();
    println!(
        &quot;The current UTC date is {}-{:02}-{:02} {:?} ({})&quot;,
        year,
        now.month(),
        now.day(),
        now.weekday(),
        if is_common_era { &quot;CE&quot; } else { &quot;BCE&quot; }
    );
    println!(
        &quot;And the Common Era began {} days ago&quot;,
        now.num_days_from_ce()
    );
}
</code></pre></pre>
<p><a name="ex-file-24-hours-modified"></a></p>
<a class="header" href="print.html#file-names-that-have-been-modified-in-the-last-24-hours-for-the-working-directory" id="file-names-that-have-been-modified-in-the-last-24-hours-for-the-working-directory"><h2>File names that have been modified in the last 24 hours for the working directory</h2></a>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Gets the current working directory by calling <a href="https://doc.rust-lang.org/std/env/fn.current_dir.html"><code>env::current_dir</code></a>,
then for each entries in <a href="https://doc.rust-lang.org/std/fs/fn.read_dir.html"><code>fs::read_dir</code></a>, extracts the
<a href="https://doc.rust-lang.org/std/fs/struct.DirEntry.html#method.path"><code>DirEntry::path</code></a> and gets the metadata via <a href="https://doc.rust-lang.org/std/fs/struct.Metadata.html"><code>fs::Metadata</code></a>. The
<a href="https://doc.rust-lang.org/std/fs/struct.Metadata.html#method.modified"><code>Metadata::modified</code></a> returns the <a href="https://doc.rust-lang.org/std/time/struct.SystemTime.html#method.elapsed"><code>SystemTime::elapsed</code></a> time since
last modification of the entry. It's converted into seconds with
<a href="https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_secs"><code>Duration::as_secs</code></a> and compared with 24 hours (24 * 60 * 60
seconds). <a href="https://doc.rust-lang.org/std/fs/struct.Metadata.html#method.is_file"><code>Metadata::is_file</code></a> is used to filter out directories.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
#
use std::{env, fs};

# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#         SystemTimeError(std::time::SystemTimeError);
#     }
# }
#
fn run() -&gt; Result&lt;()&gt; {
    let current_dir = env::current_dir()?;
    println!(
        &quot;Entries modified in the last 24 hours in {:?}:&quot;,
        current_dir
    );

    for entry in fs::read_dir(current_dir)? {
        let entry = entry?;
        let path = entry.path();

        let metadata = fs::metadata(&amp;path)?;
        let last_modified = metadata.modified()?.elapsed()?.as_secs();

        if last_modified &lt; 24 * 3600 &amp;&amp; metadata.is_file() {
            println!(
                &quot;Last modified: {:?} seconds, is read only: {:?}, size: {:?} bytes, filename: {:?}&quot;,
                last_modified,
                metadata.permissions().readonly(),
                metadata.len(),
                path.file_name().ok_or(&quot;No filename&quot;)?
            );
        }
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<!-- API Reference -->
<!-- Other Reference -->
<a class="header" href="print.html#encoding" id="encoding"><h1>Encoding</h1></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="print.html#ex-json-value">Serialize and deserialize unstructured JSON</a> </td><td> <a href="https://docs.rs/serde_json/*/serde_json/"><img src="https://badge-cache.kominick.com/crates/v/serde_json.svg?label=serde_json" alt="serde-json-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-toml-config">Deserialize a TOML configuration file</a> </td><td> <a href="https://docs.rs/toml/"><img src="https://badge-cache.kominick.com/crates/v/toml.svg?label=toml" alt="toml-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-percent-encode">Percent-encode a string</a> </td><td> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-urlencoded">Encode a string as application/x-www-form-urlencoded</a> </td><td> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-hex-encode-decode">Encode and decode hex</a> </td><td> <a href="https://docs.rs/data-encoding/"><img src="https://badge-cache.kominick.com/crates/v/data-encoding.svg?label=data-encoding" alt="data-encoding-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-base64">Encode and decode base64</a> </td><td> <a href="https://docs.rs/base64/"><img src="https://badge-cache.kominick.com/crates/v/base64.svg?label=base64" alt="base64-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-csv-read">Read CSV records</a> </td><td> <a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-csv-delimiter">Read CSV records with different delimiter</a> </td><td> <a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-csv-filter">Filter CSV records matching a predicate</a> </td><td> <a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-invalid-csv">Handle invalid CSV data with Serde</a> </td><td> <a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-serialize-csv">Serialize records to CSV</a> </td><td> <a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-csv-serde">Serialize records to CSV using Serde</a> </td><td> <a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-csv-transform-column">Transform one column of a CSV file</a> </td><td> <a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-mime-from-string">Get MIME type from string</a> </td><td> <a href="https://docs.rs/mime/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=mime" alt="mime-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
</tbody></table>
<p><a name="ex-json-value"></a></p>
<a class="header" href="print.html#serialize-and-deserialize-unstructured-json" id="serialize-and-deserialize-unstructured-json"><h2>Serialize and deserialize unstructured JSON</h2></a>
<p><a href="https://docs.rs/serde_json/*/serde_json/"><img src="https://badge-cache.kominick.com/crates/v/serde_json.svg?label=serde_json" alt="serde-json-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>The [serde_json] crate provides a <a href="https://docs.rs/serde_json/*/serde_json/fn.from_str.html"><code>serde_json::from_str</code></a> function to parse a <code>&amp;str</code> of
JSON into a type of the caller's choice.</p>
<p>Unstructured JSON can be parsed into a universal <a href="https://docs.rs/serde_json/*/serde_json/enum.Value.html"><code>serde_json::Value</code></a> type that
is able to represent any valid JSON data.</p>
<p>The example below shows a <code>&amp;str</code> of JSON being parsed and then compared to what
we expect the parsed value to be. The expected value is declared using the
<a href="https://docs.rs/serde_json/*/serde_json/macro.json.html"><code>json!</code></a> macro.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate serde_json;

use serde_json::Value;
#
# error_chain! {
#     foreign_links {
#         Json(serde_json::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let j = r#&quot;{
                 &quot;userid&quot;: 103609,
                 &quot;verified&quot;: true,
                 &quot;access_privileges&quot;: [
                   &quot;user&quot;,
                   &quot;admin&quot;
                 ]
               }&quot;#;

    let parsed: Value = serde_json::from_str(j)?;

    let expected = json!({
        &quot;userid&quot;: 103609,
        &quot;verified&quot;: true,
        &quot;access_privileges&quot;: [
            &quot;user&quot;,
            &quot;admin&quot;
        ]
    });

    assert_eq!(parsed, expected);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-toml-config"></a></p>
<a class="header" href="print.html#deserialize-a-toml-configuration-file" id="deserialize-a-toml-configuration-file"><h2>Deserialize a TOML configuration file</h2></a>
<p><a href="https://docs.rs/toml/"><img src="https://badge-cache.kominick.com/crates/v/toml.svg?label=toml" alt="toml-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Parse some TOML into a universal <code>toml::Value</code> that is able to represent any
valid TOML data.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate toml;

use toml::Value;
#
# error_chain! {
#     foreign_links {
#         Toml(toml::de::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let toml_content = r#&quot;
          [package]
          name = &quot;your_package&quot;
          version = &quot;0.1.0&quot;
          authors = [&quot;You! &lt;you@example.org&gt;&quot;]

          [dependencies]
          serde = &quot;1.0&quot;
          &quot;#;

    let package_info: Value = toml::from_str(toml_content)?;

    assert_eq!(package_info[&quot;dependencies&quot;][&quot;serde&quot;].as_str(), Some(&quot;1.0&quot;));
    assert_eq!(package_info[&quot;package&quot;][&quot;name&quot;].as_str(),
               Some(&quot;your_package&quot;));

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p>Parse TOML into your own structs using Serde:</p>
<p><a href="https://docs.rs/serde_json/*/serde_json/"><img src="https://badge-cache.kominick.com/crates/v/serde_json.svg?label=serde_json" alt="serde-json-badge" /></a> <a href="https://docs.rs/toml/"><img src="https://badge-cache.kominick.com/crates/v/toml.svg?label=toml" alt="toml-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate serde_derive;
extern crate toml;

use std::collections::HashMap;

#[derive(Deserialize)]
struct Config {
    package: Package,
    dependencies: HashMap&lt;String, String&gt;,
}

#[derive(Deserialize)]
struct Package {
    name: String,
    version: String,
    authors: Vec&lt;String&gt;,
}
#
# error_chain! {
#     foreign_links {
#         Toml(toml::de::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let toml_content = r#&quot;
          [package]
          name = &quot;your_package&quot;
          version = &quot;0.1.0&quot;
          authors = [&quot;You! &lt;you@example.org&gt;&quot;]

          [dependencies]
          serde = &quot;1.0&quot;
          &quot;#;

    let package_info: Config = toml::from_str(toml_content)?;

    assert_eq!(package_info.package.name, &quot;your_package&quot;);
    assert_eq!(package_info.package.version, &quot;0.1.0&quot;);
    assert_eq!(package_info.package.authors, vec![&quot;You! &lt;you@example.org&gt;&quot;]);
    assert_eq!(package_info.dependencies[&quot;serde&quot;], &quot;1.0&quot;);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-percent-encode"></a></p>
<a class="header" href="print.html#percent-encode-a-string" id="percent-encode-a-string"><h2>Percent-encode a string</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Encode an input string with <a href="https://en.wikipedia.org/wiki/Percent-encoding">percent-encoding</a> using the <a href="https://docs.rs/percent-encoding/*/percent_encoding/fn.utf8_percent_encode.html"><code>utf8_percent_encode</code></a>
function from the <code>url</code> crate. Then decode using the <a href="https://docs.rs/percent-encoding/*/percent_encoding/fn.percent_decode.html"><code>percent_decode</code></a>
function.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::percent_encoding::{utf8_percent_encode, percent_decode, DEFAULT_ENCODE_SET};
#
# error_chain! {
#     foreign_links {
#         Utf8(std::str::Utf8Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let input = &quot;confident, productive systems programming&quot;;

    let iter = utf8_percent_encode(input, DEFAULT_ENCODE_SET);
    let encoded: String = iter.collect();
    assert_eq!(encoded, &quot;confident,%20productive%20systems%20programming&quot;);

    let iter = percent_decode(encoded.as_bytes());
    let decoded = iter.decode_utf8()?;
    assert_eq!(decoded, &quot;confident, productive systems programming&quot;);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p>The encode set defines which bytes (in addition to non-ASCII and controls) need
to be percent-encoded. The choice of this set depends on context. For example,
<code>?</code> needs to be encoded in a URL path but not in a query string.</p>
<p>The return value of encoding is an iterator of <code>&amp;str</code> slices which can be
collected into a <code>String</code>.</p>
<p><a name="ex-urlencoded"></a></p>
<a class="header" href="print.html#encode-a-string-as-applicationx-www-form-urlencoded" id="encode-a-string-as-applicationx-www-form-urlencoded"><h2>Encode a string as application/x-www-form-urlencoded</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Encodes a string into <a href="https://url.spec.whatwg.org/#application/x-www-form-urlencoded">application/x-www-form-urlencoded</a> syntax
using the <a href="https://docs.rs/url/*/url/form_urlencoded/fn.byte_serialize.html"><code>form_urlencoded::byte_serialize</code></a> and subsequently
decodes it with <a href="https://docs.rs/url/*/url/form_urlencoded/fn.parse.html"><code>form_urlencoded::parse</code></a>. Both functions return iterators
that can be collected into a <code>String</code>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate url;
use url::form_urlencoded::{byte_serialize, parse};

fn main() {
    let urlencoded: String = byte_serialize(&quot;What is ❤?&quot;.as_bytes()).collect();
    assert_eq!(urlencoded, &quot;What+is+%E2%9D%A4%3F&quot;);
    println!(&quot;urlencoded:'{}'&quot;, urlencoded);

    let decoded: String = parse(urlencoded.as_bytes())
        .map(|(key, val)| [key, val].concat())
        .collect();
    assert_eq!(decoded, &quot;What is ❤?&quot;);
    println!(&quot;decoded:'{}'&quot;, decoded);
}
</code></pre></pre>
<p><a name="ex-hex-encode-decode"></a></p>
<a class="header" href="print.html#encode-and-decode-hex" id="encode-and-decode-hex"><h2>Encode and decode hex</h2></a>
<p><a href="https://docs.rs/data-encoding/"><img src="https://badge-cache.kominick.com/crates/v/data-encoding.svg?label=data-encoding" alt="data-encoding-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>The <a href="https://github.com/ia0/data-encoding"><code>data_encoding</code></a> crate provides a <code>HEXUPPER::encode</code> method which
takes a <code>&amp;[u8]</code> and returns a <code>String</code> containing the hexadecimal
representation of the data.</p>
<p>Similarly, a <code>HEXUPPER::decode</code> method is provided which takes a <code>&amp;[u8]</code> and
returns a <code>Vec&lt;u8&gt;</code> if the input data is successfully decoded.</p>
<p>The example below shows a <code>&amp;[u8]</code> of data being converted to its hexadecimal
representation and then being compared to its expected value. The returned
hex <code>String</code> is then converted back to its original representation and is
compared to the original value provided.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate data_encoding;

use data_encoding::{HEXUPPER, DecodeError};
#
# error_chain! {
#     foreign_links {
#         Decode(DecodeError);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let original = b&quot;The quick brown fox jumps over the lazy dog.&quot;;
    let expected = &quot;54686520717569636B2062726F776E20666F78206A756D7073206F76\
        657220746865206C617A7920646F672E&quot;;

    let encoded = HEXUPPER.encode(original);
    assert_eq!(encoded, expected);

    let decoded = HEXUPPER.decode(&amp;encoded.into_bytes())?;
    assert_eq!(&amp;decoded[..], &amp;original[..]);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-base64"></a></p>
<a class="header" href="print.html#encode-and-decode-base64" id="encode-and-decode-base64"><h2>Encode and decode base64</h2></a>
<p><a href="https://docs.rs/base64/"><img src="https://badge-cache.kominick.com/crates/v/base64.svg?label=base64" alt="base64-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Encodes byte slice into <code>base64</code> String with help of <a href="https://docs.rs/base64/*/base64/fn.encode.html"><code>encode</code></a>
and subsequently decodes it with <a href="https://docs.rs/base64/*/base64/fn.decode.html"><code>decode</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate base64;

use std::str;
use base64::{encode, decode};
#
# error_chain! {
#     foreign_links {
#         Base64(base64::DecodeError);
#         Utf8Error(str::Utf8Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let hello = b&quot;hello rustaceans&quot;;
    let encoded = encode(hello);
    let decoded = decode(&amp;encoded)?;

    println!(&quot;origin: {}&quot;, str::from_utf8(hello)?);
    println!(&quot;base64 encoded: {}&quot;, encoded);
    println!(&quot;back to origin: {}&quot;, str::from_utf8(&amp;decoded)?);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-csv-read"></a></p>
<a class="header" href="print.html#read-csv-records" id="read-csv-records"><h2>Read CSV records</h2></a>
<p><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Reads standard CSV records into <a href="https://docs.rs/csv/*/csv/struct.StringRecord.html"><code>csv::StringRecord</code></a> — a weakly typed
data representation. It expects to read valid UTF-8 rows. On the
other hand, if invalid UTF-8 data has to be read, then prefer using
<a href="https://docs.rs/csv/*/csv/struct.ByteRecord.html"><code>csv::ByteRecord</code></a>, since it makes no assumptions about UTF-8.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate csv;
# #[macro_use]
# extern crate error_chain;
#
# error_chain! {
#     foreign_links {
#         Reader(csv::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let csv = &quot;year,make,model,description
1948,Porsche,356,Luxury sports car
1967,Ford,Mustang fastback 1967,American car&quot;;

    let mut reader = csv::Reader::from_reader(csv.as_bytes());
    for record in reader.records() {
        let record = record?;
        println!(
            &quot;In {}, {} built the {} model. It is a {}.&quot;,
            &amp;record[0],
            &amp;record[1],
            &amp;record[2],
            &amp;record[3]
        );
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p>This is like the previous example, however Serde is used to
deserialize data into strongly type structures. See the
<a href="https://docs.rs/csv/*/csv/struct.Reader.html#method.deserialize"><code>csv::Reader::deserialize</code></a> method.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate csv;
# #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate serde_derive;

# error_chain! {
#     foreign_links {
#         Reader(csv::Error);
#     }
# }
#
#[derive(Deserialize)]
struct Record {
    year: u16,
    make: String,
    model: String,
    description: String,
}

fn run() -&gt; Result&lt;()&gt; {
    let csv = &quot;year,make,model,description
1948,Porsche,356,Luxury sports car
1967,Ford,Mustang fastback 1967,American car&quot;;

    let mut reader = csv::Reader::from_reader(csv.as_bytes());

    for record in reader.deserialize() {
        let record: Record = record?;
        println!(
            &quot;In {}, {} built the {} model. It is a {}.&quot;,
            record.year,
            record.make,
            record.model,
            record.description
        );
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-csv-delimiter"></a></p>
<a class="header" href="print.html#read-csv-records-with-different-delimiter" id="read-csv-records-with-different-delimiter"><h2>Read CSV records with different delimiter</h2></a>
<p><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Reads CSV records with <a href="https://docs.rs/csv/1.0.0-beta.3/csv/struct.ReaderBuilder.html#method.delimiter"><code>delimiter</code></a> other than ','</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate csv;
#[macro_use]
extern crate serde_derive;

#[derive(Debug, Deserialize)]
struct Record {
    name: String,
    place: String,
    #[serde(deserialize_with = &quot;csv::invalid_option&quot;)]
    id: Option&lt;u64&gt;,
}

use csv::ReaderBuilder;
#
# error_chain! {
#     foreign_links {
#         CsvError(csv::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let data = &quot;name-place-id
Mark-Melbourne-46
Ashley-Zurich-92&quot;;

    let mut reader = ReaderBuilder::new().delimiter(b'-').from_reader(data.as_bytes());
    for result in reader.records() {
        println!(&quot;{:?}&quot;, result?);
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-csv-filter"></a></p>
<a class="header" href="print.html#filter-csv-records-matching-a-predicate" id="filter-csv-records-matching-a-predicate"><h2>Filter CSV records matching a predicate</h2></a>
<p><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Returns <em>only</em> the rows from <code>data</code> with a field that matches <code>query</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate csv;

use std::io;
#
# error_chain!{
#     foreign_links {
#         Io(std::io::Error);
#         CsvError(csv::Error); // or just Seek(csv::Error)
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let query = &quot;CA&quot;;
    let data = &quot;\
City,State,Population,Latitude,Longitude
Kenai,AK,7610,60.5544444,-151.2583333
Oakman,AL,,33.7133333,-87.3886111
Sandfort,AL,,32.3380556,-85.2233333
West Hollywood,CA,37031,34.0900000,-118.3608333&quot;;

    let mut rdr = csv::ReaderBuilder::new().from_reader(data.as_bytes());
    let mut wtr = csv::Writer::from_writer(io::stdout());

    wtr.write_record(rdr.headers()?)?;

    for result in rdr.records() {
        let record = result?;
        if record.iter().any(|field| field == query) {
            wtr.write_record(&amp;record)?;
        }
    }

    wtr.flush()?;
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><em>Disclaimer: this example has been adapted from <a href="https://docs.rs/csv/*/csv/tutorial/index.html#filter-by-search">the csv crate tutorial</a></em>.</p>
<p><a name="ex-invalid-csv"></a></p>
<a class="header" href="print.html#handle-invalid-csv-data-with-serde" id="handle-invalid-csv-data-with-serde"><h2>Handle invalid CSV data with Serde</h2></a>
<p><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>CSV files often contain invalid data. For these cases, the csv crate
provides a custom deserializer, <a href="https://docs.rs/csv/*/csv/fn.invalid_option.html"><code>csv::invalid_option</code></a>, which automatically
converts invalid data to None values.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate csv;
#[macro_use]
extern crate serde_derive;

#[derive(Debug, Deserialize)]
struct Record {
    name: String,
    place: String,
    #[serde(deserialize_with = &quot;csv::invalid_option&quot;)]
    id: Option&lt;u64&gt;,
}
#
# error_chain! {
#     foreign_links {
#         CsvError(csv::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let data = &quot;name,place,id
mark,sydney,46.5
ashley,zurich,92
akshat,delhi,37
alisha,colombo,xyz&quot;;

    let mut rdr = csv::Reader::from_reader(data.as_bytes());
    for result in rdr.deserialize() {
        let record: Record = result?;
        println!(&quot;{:?}&quot;, record);
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-serialize-csv"></a></p>
<a class="header" href="print.html#serialize-records-to-csv" id="serialize-records-to-csv"><h2>Serialize records to CSV</h2></a>
<p><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>This example shows how to serialize a Rust tuple. <a href="https://docs.rs/csv/*/csv/struct.Writer.html"><code>csv::writer</code></a> supports automatic
serialization from Rust types into CSV records. <a href="https://docs.rs/csv/*/csv/struct.Writer.html#method.write_record"><code>write_record</code></a> is used when writing
a simple record that contains string-like data only, <a href="https://docs.rs/csv/*/csv/struct.Writer.html#method.serialize"><code>serialize</code></a> is used when data
consists of more complex values like numbers, floats or optional values. Since CSV
writer uses internal buffer, always explicitly <a href="https://docs.rs/csv/*/csv/struct.Writer.html#method.flush"><code>flush</code></a> when done.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate csv;

use std::io;
#
# error_chain! {
#     foreign_links {
#         CSVError(csv::Error);
#         IOError(std::io::Error);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let mut wtr = csv::Writer::from_writer(io::stdout());

    wtr.write_record(&amp;[&quot;Name&quot;, &quot;Place&quot;, &quot;ID&quot;])?;

    wtr.serialize((&quot;Mark&quot;, &quot;Sydney&quot;, 87))?;
    wtr.serialize((&quot;Ashley&quot;, &quot;Dublin&quot;, 32))?;
    wtr.serialize((&quot;Akshat&quot;, &quot;Delhi&quot;, 11))?;

    wtr.flush()?;
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-csv-serde"></a></p>
<a class="header" href="print.html#serialize-records-to-csv-using-serde" id="serialize-records-to-csv-using-serde"><h2>Serialize records to CSV using Serde</h2></a>
<p><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>The following example shows how to serialize custom structs as CSV records using
the <a href="https://docs.rs/serde/">serde</a> crate.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate csv;
#[macro_use]
extern crate serde_derive;

use std::io;
#
# error_chain! {
#    foreign_links {
#        IOError(std::io::Error);
#        CSVError(csv::Error);
#    }
# }

#[derive(Serialize)]
struct Record&lt;'a&gt; {
    name: &amp;'a str,
    place: &amp;'a str,
    id: u64,
}

fn run() -&gt; Result&lt;()&gt; {
    let mut wtr = csv::Writer::from_writer(io::stdout());

    let rec1 = Record { name: &quot;Mark&quot;, place: &quot;Melbourne&quot;, id: 56};
    let rec2 = Record { name: &quot;Ashley&quot;, place: &quot;Sydney&quot;, id: 64};
    let rec3 = Record { name: &quot;Akshat&quot;, place: &quot;Delhi&quot;, id: 98};

    wtr.serialize(rec1)?;
    wtr.serialize(rec2)?;
    wtr.serialize(rec3)?;

    wtr.flush()?;

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-csv-transform-column"></a></p>
<a class="header" href="print.html#transform-csv-column" id="transform-csv-column"><h2>Transform CSV column</h2></a>
<p><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Transform a CSV file containing a color name and a hex color into one with a
color name and an rgb color.  Utilizes the <a href="https://docs.rs/csv/">csv</a> crate to read and write the
csv file, and <a href="https://docs.rs/serde/">serde</a> to deserialize and serialize the rows to and from bytes.</p>
<p>See <a href="https://docs.rs/csv/*/csv/struct.Reader.html#method.deserialize"><code>csv::Reader::deserialize</code></a>, <a href="https://docs.rs/serde/*/serde/trait.Deserialize.html"><code>serde::Deserialize</code></a>, and <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>std::str::FromStr</code></a></p>
<pre><pre class="playpen"><code class="language-rust">extern crate csv;
# #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate serde_derive;
extern crate serde;

use csv::{Reader, Writer};
use serde::{de, Deserialize, Deserializer};
use std::str::FromStr;
#
# error_chain! {
#    foreign_links {
#        CsvError(csv::Error);
#        ParseInt(std::num::ParseIntError);
#        CsvInnerError(csv::IntoInnerError&lt;Writer&lt;Vec&lt;u8&gt;&gt;&gt;);
#        IO(std::fmt::Error);
#        UTF8(std::string::FromUtf8Error);
#    }
# }

#[derive(Debug)]
struct HexColor {
    red: u8,
    green: u8,
    blue: u8,
}

#[derive(Debug, Deserialize)]
struct Row {
    color_name: String,
    color: HexColor,
}

impl FromStr for HexColor {
    type Err = Error;

    fn from_str(hex_color: &amp;str) -&gt; std::result::Result&lt;Self, Self::Err&gt; {
        let trimmed = hex_color.trim_matches('#');
        if trimmed.len() != 6 {
            Err(&quot;Invalid length of hex string&quot;.into())
        } else {
            Ok(HexColor {
                red: u8::from_str_radix(&amp;trimmed[..2], 16)?,
                green: u8::from_str_radix(&amp;trimmed[2..4], 16)?,
                blue: u8::from_str_radix(&amp;trimmed[4..6], 16)?,
            })
        }
    }
}

impl&lt;'de&gt; Deserialize&lt;'de&gt; for HexColor {
    fn deserialize&lt;D&gt;(deserializer: D) -&gt; std::result::Result&lt;Self, D::Error&gt;
    where
        D: Deserializer&lt;'de&gt;,
    {
        let s = String::deserialize(deserializer)?;
        FromStr::from_str(&amp;s).map_err(de::Error::custom)
    }
}

fn run() -&gt; Result&lt;()&gt; {
    let data = &quot;color_name,color
red,#ff0000
green,#00ff00
blue,#0000FF
periwinkle,#ccccff
magenta,#ff00ff&quot;
        .to_owned();
    let mut out = Writer::from_writer(vec![]);
    let mut reader = Reader::from_reader(data.as_bytes());
    for result in reader.deserialize::&lt;Row&gt;() {
        let res = result?;
        out.serialize((
            res.color_name,
            res.color.red,
            res.color.green,
            res.color.blue,
        ))?;
    }
    let written = String::from_utf8(out.into_inner()?)?;
    assert_eq!(Some(&quot;magenta,255,0,255&quot;), written.lines().last());
    println!(&quot;{}&quot;, written);
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-mime-from-string"></a></p>
<a class="header" href="print.html#get-mime-type-from-string" id="get-mime-type-from-string"><h2>Get MIME type from string</h2></a>
<p><a href="https://docs.rs/mime/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=mime" alt="mime-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>The following example shows how to parse a <a href="https://docs.rs/mime/*/mime/struct.Mime.html"><code>MIME</code></a> type from a string using the <a href="https://docs.rs/mime/">mime</a> crate. You can handle a possible <a href="https://docs.rs/mime/*/mime/struct.FromStrError.html"><code>FromStrError</code></a> by providing a default <a href="https://docs.rs/mime/*/mime/struct.Mime.html"><code>MIME</code></a> type in an <code>unwrap_or</code> clause.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate mime;
use mime::{Mime, APPLICATION_OCTET_STREAM};

fn main() {
    let invalid_mime_type = &quot;i n v a l i d&quot;;
    let default_mime = invalid_mime_type
        .parse::&lt;Mime&gt;()
        .unwrap_or(APPLICATION_OCTET_STREAM);

    println!(
        &quot;MIME for {:?} used default value {:?}&quot;,
        invalid_mime_type, default_mime
    );

    let valid_mime_type = &quot;TEXT/PLAIN&quot;;
    let parsed_mime = valid_mime_type
        .parse::&lt;Mime&gt;()
        .unwrap_or(APPLICATION_OCTET_STREAM);

    println!(
        &quot;MIME for {:?} was parsed as {:?}&quot;,
        valid_mime_type, parsed_mime
    );
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<!-- API Reference -->
<!-- Other Reference -->
<a class="header" href="print.html#concurrency" id="concurrency"><h1>Concurrency</h1></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="print.html#ex-rayon-iter-mut">Mutate the elements of an array in parallel</a> </td><td> <a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rayon-any-all">Test in parallel if any or all elements of a collection match a given predicate</a> </td><td> <a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rayon-parallel-search">Search items using given predicate in parallel</a> </td><td> <a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rayon-parallel-sort">Sort a vector in parallel</a> </td><td> <a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rayon-map-reduce">Map-reduce in parallel</a> </td><td> <a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rayon-thumbnails">Generate jpg thumbnails in parallel</a> </td><td> <a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://docs.rs/glob/"><img src="https://badge-cache.kominick.com/crates/v/glob.svg?label=glob" alt="glob-badge" /></a> <a href="https://docs.rs/image/"><img src="https://badge-cache.kominick.com/crates/v/image.svg?label=image" alt="image-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-crossbeam-spawn">Spawn a short-lived thread</a> </td><td> <a href="https://docs.rs/crossbeam/"><img src="https://badge-cache.kominick.com/crates/v/crossbeam.svg?label=crossbeam" alt="crossbeam-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-threadpool-fractal">Draw fractal dispatching work to a thread pool</a> </td><td> <a href="https://docs.rs/threadpool/"><img src="https://badge-cache.kominick.com/crates/v/threadpool.svg?label=threadpool" alt="threadpool-badge" /></a> <a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a> <a href="https://docs.rs/num_cpus/"><img src="https://badge-cache.kominick.com/crates/v/num_cpus.svg?label=num_cpus" alt="num_cpus-badge" /></a> <a href="https://docs.rs/image/"><img src="https://badge-cache.kominick.com/crates/v/image.svg?label=image" alt="image-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a><a href="https://crates.io/categories/rendering"><img src="https://badge-cache.kominick.com/badge/rendering--x.svg?style=social" alt="cat-rendering-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-threadpool-walk">Calculate SHA1 sum of *.iso files concurrently</a>  </td><td> <a href="https://docs.rs/threadpool/"><img src="https://badge-cache.kominick.com/crates/v/threadpool.svg?label=threadpool" alt="threadpool-badge" /></a> <a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> <a href="https://docs.rs/num_cpus/"><img src="https://badge-cache.kominick.com/crates/v/num_cpus.svg?label=num_cpus" alt="num_cpus-badge" /></a> <a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
</tbody></table>
<p><a name="ex-rayon-iter-mut"></a></p>
<a class="header" href="print.html#mutate-the-elements-of-an-array-in-parallel" id="mutate-the-elements-of-an-array-in-parallel"><h2>Mutate the elements of an array in parallel</h2></a>
<p><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></p>
<p>The example uses the <code>rayon</code> crate, which is a data parallelism library for Rust.
<code>rayon</code> provides the <a href="https://docs.rs/rayon/*/rayon/iter/trait.IntoParallelRefMutIterator.html#tymethod.par_iter_mut"><code>par_iter_mut</code></a> method for any parallel iterable data type.
It lets us write iterator-like chains that execute in parallel.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rayon;

use rayon::prelude::*;

fn main() {
    let mut arr = [0, 7, 9, 11];

    arr.par_iter_mut().for_each(|p| *p -= 1);

    println!(&quot;{:?}&quot;, arr);
}
</code></pre></pre>
<p><a name="ex-rayon-any-all"></a></p>
<a class="header" href="print.html#test-in-parallel-if-any-or-all-elements-of-a-collection-match-a-given-predicate" id="test-in-parallel-if-any-or-all-elements-of-a-collection-match-a-given-predicate"><h2>Test in parallel if any or all elements of a collection match a given predicate</h2></a>
<p><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></p>
<p>This example demonstrates using the <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.any"><code>rayon::any</code></a> and <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.all"><code>rayon::all</code></a> methods, which are parallelized counterparts to <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.any"><code>std::any</code></a> and <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.all"><code>std::all</code></a>. <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.any"><code>rayon::any</code></a> checks in parallel whether any element of the iterator matches the predicate, and returns as soon as one is found. <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.all"><code>rayon::all</code></a> checks in parallel whether all elements of the iterator match the predicate, and returns as soon as a non-matching element is found.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rayon;

use rayon::prelude::*;

fn main() {
    let mut vec = vec![2, 4, 6, 8];

    assert!(!vec.par_iter().any(|n| (*n % 2) != 0)); // None are odd.
    assert!(vec.par_iter().all(|n| (*n % 2) == 0)); // All are even.
    assert!(!vec.par_iter().any(|n| *n &gt; 8 )); // None are greater than 8.
    assert!(vec.par_iter().all(|n| *n &lt;= 8 )); // All are less than or equal to 8.

    vec.push(9);

    assert!(vec.par_iter().any(|n| (*n % 2) != 0)); // At least 1 is odd.
    assert!(!vec.par_iter().all(|n| (*n % 2) == 0)); // Not all are even.
    assert!(vec.par_iter().any(|n| *n &gt; 8 )); // At least 1 is greater than 8.
    assert!(!vec.par_iter().all(|n| *n &lt;= 8 )); // Not all are less than or equal to 8.
}
</code></pre></pre>
<p><a name="ex-rayon-parallel-sort"></a></p>
<a class="header" href="print.html#sort-a-vector-in-parallel" id="sort-a-vector-in-parallel"><h2>Sort a vector in parallel</h2></a>
<p><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></p>
<p>This example will sort in parallel a vector of Strings.</p>
<p>[1] We start by preallocating a vector of empty Strings, so we can mutate the information in parallel later,
to populate the vector with random Strings.</p>
<p>[2] <code>par_iter_mut().for_each</code> takes a closure and applies it in parallel on all the elements of the vector.<br/>
[3] Inside the passed closure we modify the element in the vector with a 5 character-long String, random generated.</p>
<p>[4] We have <a href="https://docs.rs/rayon/*/rayon/slice/trait.ParallelSliceMut.html"><code>multiple options</code></a> to sort an Iterable data type, we chose here to use <a href="https://docs.rs/rayon/*/rayon/slice/trait.ParallelSliceMut.html#method.par_sort_unstable"><code>par_sort_unstable</code></a>
because it is usually faster than <a href="https://docs.rs/rayon/*/rayon/slice/trait.ParallelSliceMut.html#method.par_sort"><code>stable sorting</code></a> algorithms which <code>rayon</code> also supports.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;
extern crate rayon;

use rand::{Rng, thread_rng};
use rand::distributions::Alphanumeric;
use rayon::prelude::*;

fn main() {
    // [1]
    let mut vec = vec![String::new(); 100_000];

    // [2]
    vec.par_iter_mut().for_each(|p| {
        // [3]
        let mut rng = thread_rng();
        *p = (0..5).map(|_| rng.sample(&amp;Alphanumeric)).collect()
    });

    // [4]
    vec.par_sort_unstable();
}
</code></pre></pre>
<p><a name="ex-rayon-map-reduce"></a></p>
<a class="header" href="print.html#map-reduce-in-parallel" id="map-reduce-in-parallel"><h2>Map-reduce in parallel</h2></a>
<p><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></p>
<p>This example uses <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.filter"><code>rayon::filter</code></a>, <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.map"><code>rayon::map</code></a>, and <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.reduce"><code>rayon::reduce</code></a>
to calculate the conditional average age of a vector of <code>Person</code> objects.</p>
<p><a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.filter"><code>rayon::filter</code></a> allows us to (in parallel) conditionally include elements from
a collection that satisfy the given predicate.  Similarly, <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.map"><code>rayon::map</code></a> and
<a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.reduce"><code>rayon::reduce</code></a> allow us to transform the filtered elements via a unary
operation and reduce them to a single value via a given binary operation,
respectively. We also show use of <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.sum"><code>rayon::sum</code></a>, which has the same result as
the reduce operation in this example.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rayon;

use rayon::prelude::*;

struct Person {
    age: u32,
}

fn main() {
    let v: Vec&lt;Person&gt; = vec![
        Person { age: 23 },
        Person { age: 19 },
        Person { age: 42 },
        Person { age: 17 },
        Person { age: 17 },
        Person { age: 31 },
        Person { age: 30 },
    ];

    let num_over_30 = v.par_iter().filter(|&amp;x| x.age &gt; 30).count() as f32;
    let sum_over_30 = v.par_iter()
        .map(|x| x.age)
        .filter(|&amp;x| x &gt; 30)
        .reduce(|| 0, |x, y| x + y);

    let alt_sum_30: u32 = v.par_iter()
        .map(|x| x.age)
        .filter(|&amp;x| x &gt; 30)
        .sum();

    let avg_over_30 = sum_over_30 as f32 / num_over_30;
    let alt_avg_over_30 = alt_sum_30 as f32/ num_over_30;

    assert!((avg_over_30 - alt_avg_over_30).abs() &lt; std::f32::EPSILON);
    println!(&quot;The average age of people older than 30 is {}&quot;, avg_over_30);
}
</code></pre></pre>
<p><a name="ex-rayon-parallel-search"></a></p>
<a class="header" href="print.html#search-items-using-given-predicate-in-parallel" id="search-items-using-given-predicate-in-parallel"><h2>Search items using given predicate in parallel</h2></a>
<p><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></p>
<p>This example uses <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.find_any"><code>rayon::find_any</code></a> and <a href="https://docs.rs/rayon/*/rayon/iter/trait.IntoParallelRefIterator.html#tymethod.par_iter"><code>par_iter</code></a> to search a vector in
parallel for an element satisfying the predicate in the given closure.</p>
<p>If there are multiple elements satisfying the predicate defined in the closure
argument of <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.find_any"><code>rayon::find_any</code></a>, we are only guaranteed that one of them will be
found, but not necessarily that the first will be found.</p>
<p>Also note that the argument to the closure is a reference to a reference
(<code>&amp;&amp;x</code>). Please see the discussion on <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find"><code>std::find</code></a> for additional details.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rayon;

use rayon::prelude::*;

fn main() {
    let v = vec![6, 2, 1, 9, 3, 8, 11];

    let f1 = v.par_iter().find_any(|&amp;&amp;x| x == 9);
    let f2 = v.par_iter().find_any(|&amp;&amp;x| x % 2 == 0 &amp;&amp; x &gt; 6);
    let f3 = v.par_iter().find_any(|&amp;&amp;x| x &gt; 8);

    assert_eq!(f1, Some(&amp;9));
    assert_eq!(f2, Some(&amp;8));
    assert!(f3 &gt; Some(&amp;8));
}
</code></pre></pre>
<p><a name="ex-rayon-thumbnails"></a></p>
<a class="header" href="print.html#generate-jpg-thumbnails-in-parallel" id="generate-jpg-thumbnails-in-parallel"><h2>Generate jpg thumbnails in parallel</h2></a>
<p><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://docs.rs/glob/"><img src="https://badge-cache.kominick.com/crates/v/glob.svg?label=glob" alt="glob-badge" /></a> <a href="https://docs.rs/image/"><img src="https://badge-cache.kominick.com/crates/v/image.svg?label=image" alt="image-badge" /></a> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>This example generates thumbnails for all .jpg in the current directory and saves them in a new folder called <code>thumbnails</code>.</p>
<p>Files are found using <a href="https://docs.rs/glob/*/glob/fn.glob_with.html"><code>glob::glob_with</code></a> to match case insensitively on both <code>.jpg</code> and <code>.JPG</code>. <code>rayon</code> is then used to resize images in parallel using <a href="https://docs.rs/rayon/*/rayon/iter/trait.IntoParallelRefIterator.html#tymethod.par_iter"><code>par_iter</code></a> along with the <code>make_thumbnail()</code> helper function which internally uses <a href="https://docs.rs/image/*/image/enum.DynamicImage.html#method.resize"><code>DynamicImage::resize</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate glob;
extern crate image;
extern crate rayon;

use std::path::Path;
use std::fs::create_dir_all;

# use error_chain::ChainedError;
use glob::{glob_with, MatchOptions};
use image::{FilterType, ImageError};
use rayon::prelude::*;

# error_chain! {
#     foreign_links {
#         Image(ImageError);
#         Io(std::io::Error);
#         Glob(glob::PatternError);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    // find all files in current directory that have a .jpg extension
    // use the default MatchOptions so the search is case insensitive
    let options: MatchOptions = Default::default();
    let files: Vec&lt;_&gt; = glob_with(&quot;*.jpg&quot;, &amp;options)?
        .filter_map(|x| x.ok())
        .collect();

    if files.len() == 0 {
        bail!(&quot;No .jpg files found in current directory&quot;);
    }

    let thumb_dir = &quot;thumbnails&quot;;
    create_dir_all(thumb_dir)?;

    println!(&quot;Saving {} thumbnails into '{}'...&quot;, files.len(), thumb_dir);

    let image_failures: Vec&lt;_&gt; = files
        .par_iter()
        .map(|path| {
            make_thumbnail(path, thumb_dir, 300)
                .map_err(|e| e.chain_err(|| path.display().to_string()))
        })
        .filter_map(|x| x.err())
        .collect();

    image_failures.iter().for_each(|x| println!(&quot;{}&quot;, x.display_chain()));

    println!(&quot;{} thumbnails saved successfully&quot;, files.len() - image_failures.len());
    Ok(())
}

/// Resize `original` to have a maximum dimension of `longest_edge` and save the
/// resized image to the `thumb_dir` folder
fn make_thumbnail&lt;PA, PB&gt;(original: PA, thumb_dir: PB, longest_edge: u32) -&gt; Result&lt;()&gt;
where
    PA: AsRef&lt;Path&gt;,
    PB: AsRef&lt;Path&gt;,
{
    let img = image::open(original.as_ref())?;
    let file_path = thumb_dir.as_ref().join(original);

    Ok(img.resize(longest_edge, longest_edge, FilterType::Nearest)
          .save(file_path)?)
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-crossbeam-spawn"></a></p>
<a class="header" href="print.html#spawn-a-short-lived-thread" id="spawn-a-short-lived-thread"><h2>Spawn a short-lived thread</h2></a>
<p><a href="https://docs.rs/crossbeam/"><img src="https://badge-cache.kominick.com/crates/v/crossbeam.svg?label=crossbeam" alt="crossbeam-badge" /></a> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></p>
<p>The example uses the <code>crossbeam</code> crate, which provides data structures and functions
for concurrent and parallel programming. <a href="https://docs.rs/crossbeam/*/crossbeam/struct.Scope.html#method.spawn"><code>Scope::spawn</code></a> spawns a new scoped thread that is guaranteed
to terminate before returning from the closure that passed into <a href="https://docs.rs/crossbeam/*/crossbeam/fn.scope.html"><code>crossbeam::scope</code></a> function, meaning that
you can reference data from the calling function.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate crossbeam;

use std::cmp;

fn main() {
    let arr = &amp;[-4, 1, 10, 25];
    let max = find_max(arr, 0, arr.len());
    assert_eq!(25, max);
}

fn find_max(arr: &amp;[i32], start: usize, end: usize) -&gt; i32 {
    // Perform sequential computation if there are only a few elements.
    const THRESHOLD: usize = 2;
    if end - start &lt;= THRESHOLD {
        return *arr.iter().max().unwrap();
    }

    let mid = start + (end - start) / 2;
    crossbeam::scope(|scope| {
        let left = scope.spawn(|| find_max(arr, start, mid));
        let right = scope.spawn(|| find_max(arr, mid, end));

        cmp::max(left.join(), right.join())
    })
}
</code></pre></pre>
<p><a name="ex-threadpool-fractal"></a></p>
<a class="header" href="print.html#draw-fractal-dispatching-work-to-a-thread-pool" id="draw-fractal-dispatching-work-to-a-thread-pool"><h2>Draw fractal dispatching work to a thread pool</h2></a>
<p><a href="https://docs.rs/threadpool/"><img src="https://badge-cache.kominick.com/crates/v/threadpool.svg?label=threadpool" alt="threadpool-badge" /></a> <a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a> <a href="https://docs.rs/num_cpus/"><img src="https://badge-cache.kominick.com/crates/v/num_cpus.svg?label=num_cpus" alt="num_cpus-badge" /></a> <a href="https://docs.rs/image/"><img src="https://badge-cache.kominick.com/crates/v/image.svg?label=image" alt="image-badge" /></a> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a><a href="https://crates.io/categories/rendering"><img src="https://badge-cache.kominick.com/badge/rendering--x.svg?style=social" alt="cat-rendering-badge" /></a></p>
<p>This example draws a fractal from <a href="https://en.wikipedia.org/wiki/Julia_set">Julia set</a> to an image utilizing a thread pool for computation.</p>
<p><a href="https://cloud.githubusercontent.com/assets/221000/26546700/9be34e80-446b-11e7-81dc-dd9871614ea1.png"><img src="https://cloud.githubusercontent.com/assets/221000/26546700/9be34e80-446b-11e7-81dc-dd9871614ea1.png" width="150" /></a></p>
<p>Firstly, the example allocates memory for output image of given width and height with <a href="https://docs.rs/image/*/image/struct.ImageBuffer.html#method.new"><code>ImageBuffer::new</code></a>
and pre-calculates all possible RGB pixel values using <a href="https://docs.rs/image/*/image/struct.Rgb.html#method.from_channels"><code>Rgb::from_channels</code></a>.
Secondly, creates a new <a href="https://docs.rs/threadpool/*/threadpool/struct.ThreadPool.html"><code>ThreadPool</code></a> with thread count equal to number of
logical cores in CPU obtained with <a href="https://docs.rs/num_cpus/*/num_cpus/fn.get.html"><code>num_cpus::get</code></a>.
Subsequently, dispatches calculation to thread pool <a href="https://docs.rs/threadpool/*/threadpool/struct.ThreadPool.html#method.execute"><code>ThreadPool::execute</code></a>.</p>
<p>Lastly, collects calculation results via <a href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html"><code>mpsc::channel</code></a> with <a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.recv"><code>Receiver::recv</code></a>, draws them with <a href="https://docs.rs/image/*/image/struct.ImageBuffer.html#method.put_pixel"><code>ImageBuffer::put_pixel</code></a> and encodes the final image into <code>output.png</code> using <a href="https://docs.rs/image/*/image/struct.ImageBuffer.html#method.save"><code>ImageBuffer::save</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate threadpool;
extern crate num;
extern crate num_cpus;
extern crate image;

use std::sync::mpsc::{channel, RecvError};
use threadpool::ThreadPool;
use num::complex::Complex;
use image::{ImageBuffer, Pixel, Rgb};
#
# error_chain! {
#     foreign_links {
#         MpscRecv(RecvError);
#         Io(std::io::Error);
#     }
# }
#
# // Function converting intensity values to RGB
# // Based on http://www.efg2.com/Lab/ScienceAndEngineering/Spectra.htm
# fn wavelength_to_rgb(wavelength: u32) -&gt; Rgb&lt;u8&gt; {
#     let wave = wavelength as f32;
#
#     let (r, g, b) = match wavelength {
#         380...439 =&gt; ((440. - wave) / (440. - 380.), 0.0, 1.0),
#         440...489 =&gt; (0.0, (wave - 440.) / (490. - 440.), 1.0),
#         490...509 =&gt; (0.0, 1.0, (510. - wave) / (510. - 490.)),
#         510...579 =&gt; ((wave - 510.) / (580. - 510.), 1.0, 0.0),
#         580...644 =&gt; (1.0, (645. - wave) / (645. - 580.), 0.0),
#         645...780 =&gt; (1.0, 0.0, 0.0),
#         _ =&gt; (0.0, 0.0, 0.0),
#     };
#
#     let factor = match wavelength {
#         380...419 =&gt; 0.3 + 0.7 * (wave - 380.) / (420. - 380.),
#         701...780 =&gt; 0.3 + 0.7 * (780. - wave) / (780. - 700.),
#         _ =&gt; 1.0,
#     };
#
#     let (r, g, b) = (normalize(r, factor), normalize(g, factor), normalize(b, factor));
#     Rgb::from_channels(r, g, b, 0)
# }
#
# // Maps Julia set distance estimation to intensity values
# fn julia(c: Complex&lt;f32&gt;, x: u32, y: u32, width: u32, height: u32, max_iter: u32) -&gt; u32 {
#     let width = width as f32;
#     let height = height as f32;
#
#     let mut z = Complex {
#         // scale and translate the point to image coordinates
#         re: 3.0 * (x as f32 - 0.5 * width) / width,
#         im: 2.0 * (y as f32 - 0.5 * height) / height,
#     };
#
#     let mut i = 0;
#     for t in 0..max_iter {
#         if z.norm() &gt;= 2.0 {
#             break;
#         }
#         z = z * z + c;
#         i = t;
#     }
#     i
# }
#
# // Normalizes color intensity values within RGB range
# fn normalize(color: f32, factor: f32) -&gt; u8 {
#     ((color * factor).powf(0.8) * 255.) as u8
# }

fn run() -&gt; Result&lt;()&gt; {
    let (width, height) = (1920, 1080);
    let mut img = ImageBuffer::new(width, height);
    let iterations = 300;

    // constants to tweak for appearance
    let c = Complex::new(-0.8, 0.156);

    let pool = ThreadPool::new(num_cpus::get());
    let (tx, rx) = channel();

    for y in 0..height {
        let tx = tx.clone();
        pool.execute(move || for x in 0..width {
                         let i = julia(c, x, y, width, height, iterations);
                         let pixel = wavelength_to_rgb(380 + i * 400 / iterations);
                         tx.send((x, y, pixel)).expect(&quot;Could not send data!&quot;);
                     });
    }

    for _ in 0..(width * height) {
        let (x, y, pixel) = rx.recv()?;
        img.put_pixel(x, y, pixel);
    }
    let _ = img.save(&quot;output.png&quot;)?;
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-threadpool-walk"></a></p>
<a class="header" href="print.html#calculate-sha1-sum-of-iso-files-concurrently" id="calculate-sha1-sum-of-iso-files-concurrently"><h2>Calculate SHA1 sum of *.iso files concurrently</h2></a>
<p><a href="https://docs.rs/threadpool/"><img src="https://badge-cache.kominick.com/crates/v/threadpool.svg?label=threadpool" alt="threadpool-badge" /></a> <a href="https://docs.rs/num_cpus/"><img src="https://badge-cache.kominick.com/crates/v/num_cpus.svg?label=num_cpus" alt="num_cpus-badge" /></a> <a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> <a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>This example calculates the SHA1 for every file present in the current directory. A threadpool is created using the number of cpus present in the system with <a href="https://docs.rs/num_cpus/*/num_cpus/fn.get.html"><code>num_cpus::get</code></a>. Then every returned by <a href="https://docs.rs/walkdir/*/walkdir/struct.WalkDir.html#method.new"><code>Walkdir::new</code></a> is passed into this pool to perform the operations of reading and computing SHA1. At the end the program waits for all jobs to finish. To get better results, compile this program in release mode.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate walkdir;
extern crate ring;
extern crate num_cpus;
extern crate threadpool;

# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#     }
# }
#
use walkdir::WalkDir;
use std::fs::File;
use std::io::{BufReader, Read};
use std::path::Path;
use threadpool::ThreadPool;
use std::sync::mpsc::channel;
use ring::digest::{Context, Digest, SHA1};

# // Verify the iso extension
# fn is_iso(entry: &amp;Path) -&gt; bool {
#     match entry.extension() {
#         Some(e) if e.to_string_lossy().to_lowercase() == &quot;iso&quot; =&gt; true,
#         _ =&gt; false,
#     }
# }
#
fn compute_digest&lt;P: AsRef&lt;Path&gt;&gt;(filepath: P) -&gt; Result&lt;(Digest, P)&gt; {
    let mut buf_reader = BufReader::new(File::open(&amp;filepath)?);
    let mut context = Context::new(&amp;SHA1);
    let mut buffer = [0; 1024];

    loop {
        let count = buf_reader.read(&amp;mut buffer)?;
        if count == 0 {
            break;
        }
        context.update(&amp;buffer[..count]);
    }

    Ok((context.finish(), filepath))
}

fn run() -&gt; Result&lt;()&gt; {
    let pool = ThreadPool::new(num_cpus::get());

    let (tx, rx) = channel();

    // Look in the current directory.
    for entry in WalkDir::new(&quot;/home/user/Downloads&quot;)
        .follow_links(true)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| !e.path().is_dir() &amp;&amp; is_iso(e.path())) {
            let path = entry.path().to_owned();
            let tx = tx.clone();
            pool.execute(move || {
                let digest = compute_digest(path);
                tx.send(digest).expect(&quot;Could not send data!&quot;);
            });
        }

    drop(tx);
    for t in rx.iter() {
        let (sha, path) = t?;
        println!(&quot;{:?} {:?}&quot;, sha, path);
    }
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<!-- API Reference -->
<!-- Other Reference -->
<a class="header" href="print.html#networking" id="networking"><h1>Networking</h1></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="print.html#ex-url-parse">Parse a URL from a string to a <code>Url</code> type</a> </td><td> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-url-base">Create a base URL by removing path segments</a> </td><td> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-url-new-from-base">Create new URLs from a base URL</a> </td><td> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-url-origin">Extract the URL origin (scheme / host / port)</a> </td><td> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-url-rm-frag">Remove fragment identifiers and query pairs from a URL</a> </td><td> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-url-basic">Make a HTTP GET request</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-url-download">Download a file to a temporary directory</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/tempdir/"><img src="https://badge-cache.kominick.com/crates/v/tempdir.svg?label=tempdir" alt="tempdir-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rest-get">Query the GitHub API</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-paginated-api">Consume a paginated RESTful API</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rest-head">Check if an API resource exists</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rest-custom-params">Set custom headers and URL parameters for a REST request</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/hyper/"><img src="https://badge-cache.kominick.com/crates/v/hyper.svg?label=hyper" alt="hyper-badge" /></a> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rest-post">Create and delete Gist with GitHub API</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-file-post">POST a file to paste-rs</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-random-port-tcp">Listen on unused port TCP/IP</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-extract-links-webpage">Extract all links from a webpage HTML</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/select/"><img src="https://badge-cache.kominick.com/crates/v/select.svg?label=select" alt="select-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-check-broken-links">Check webpage for broken links</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/select/"><img src="https://badge-cache.kominick.com/crates/v/select.svg?label=select" alt="select-badge" /></a> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-extract-mediawiki-links">Extract all unique links from a MediaWiki markup</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-progress-with-range">Make a partial download with HTTP range headers</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-handle-rate-limited-api">Handle a rate-limited API</a> </td><td> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/hyper/"><img src="https://badge-cache.kominick.com/crates/v/hyper.svg?label=hyper" alt="hyper-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-http-response-mime-type">Parse the MIME type of a HTTP response</a> </td><td> <a href="https://docs.rs/mime/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=mime" alt="mime-badge" /></a> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
</tbody></table>
<p><a name="ex-url-parse"/></p>
<a class="header" href="print.html#parse-a-url-from-a-string-to-a-url-type" id="parse-a-url-from-a-string-to-a-url-type"><h2>Parse a URL from a string to a <code>Url</code> type</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>The <a href="https://docs.rs/url/*/url/struct.Url.html#method.parse"><code>parse</code></a> method from the <code>url</code> crate validates and parses a <code>&amp;str</code> into a
<a href="https://docs.rs/url/*/url/struct.Url.html"><code>Url</code></a> struct. The input string may be malformed so this method returns
<code>Result&lt;Url, ParseError&gt;</code>.</p>
<p>Once the URL has been parsed, it can be used with all of the methods on the
<code>Url</code> type.</p>
<p>The URL in this code parses successfully, but swapping it out for a malformed
URL will print a message containing an explanation of what went wrong.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::Url;
#
# error_chain! {
#     foreign_links {
#         UrlParse(url::ParseError);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let s = &quot;https://github.com/rust-lang/rust/issues?labels=E-easy&amp;state=open&quot;;

    let parsed = Url::parse(s)?;
    println!(&quot;The path part of the URL is: {}&quot;, parsed.path());

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-url-base"></a></p>
<a class="header" href="print.html#create-a-base-url-by-removing-path-segments" id="create-a-base-url-by-removing-path-segments"><h2>Create a base URL by removing path segments</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::Url;
#
# error_chain! {
#     foreign_links {
#         UrlParse(url::ParseError);
#     }
#     errors {
#         CannotBeABase
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let full = &quot;https://github.com/rust-lang/cargo?asdf&quot;;

    let url = Url::parse(full)?;
    let base = base_url(url)?;

    assert_eq!(base.as_str(), &quot;https://github.com/&quot;);
    println!(&quot;The base of the URL is: {}&quot;, base);

    Ok(())
}

/// Returns the base of the given URL - the part not including any path segments
/// and query parameters.
fn base_url(mut url: Url) -&gt; Result&lt;Url&gt; {
    // Clear path segments.
    match url.path_segments_mut() {
        Ok(mut path) =&gt; {
            path.clear();
        }
        Err(_) =&gt; {
            // Certain URLs cannot be turned into a base URL.
            return Err(Error::from_kind(ErrorKind::CannotBeABase));
        }
    }

    // Clear query parameters.
    url.set_query(None);

    Ok(url)
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-url-new-from-base"></a></p>
<a class="header" href="print.html#create-new-urls-from-a-base-url" id="create-new-urls-from-a-base-url"><h2>Create new URLs from a base URL</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>The <a href="https://docs.rs/url/*/url/struct.Url.html#method.join"><code>join</code></a> method creates a new URL from a base and relative path.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::Url;
#
# error_chain! {
#     foreign_links {
#         UrlParse(url::ParseError);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let path = &quot;/rust-lang/cargo&quot;;

    let gh = build_github_url(path)?;

    assert_eq!(gh.as_str(), &quot;https://github.com/rust-lang/cargo&quot;);
    println!(&quot;The joined URL is: {}&quot;, gh);

    Ok(())
}

fn build_github_url(path: &amp;str) -&gt; Result&lt;Url&gt; {
    // Hardcoded in our program. Caller's path will be joined to this.
    const GITHUB: &amp;'static str = &quot;https://github.com&quot;;

    let base = Url::parse(GITHUB).expect(&quot;hardcoded URL is known to be valid&quot;);
    let joined = base.join(path)?;

    Ok(joined)
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-url-origin"></a></p>
<a class="header" href="print.html#extract-the-url-origin-scheme--host--port" id="extract-the-url-origin-scheme--host--port"><h2>Extract the URL origin (scheme / host / port)</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>The <a href="https://docs.rs/url/*/url/struct.Url.html"><code>Url</code></a> struct exposes various methods to extract information about the URL
it represents.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::{Url, Host};

# error_chain! {
#     foreign_links {
#         UrlParse(url::ParseError);
#     }
# }
#
fn run() -&gt; Result&lt;()&gt; {
    let s = &quot;ftp://rust-lang.org/examples&quot;;

    let url = Url::parse(s)?;

    assert_eq!(url.scheme(), &quot;ftp&quot;);
    assert_eq!(url.host(), Some(Host::Domain(&quot;rust-lang.org&quot;)));
    assert_eq!(url.port_or_known_default(), Some(21));
    println!(&quot;The origin is as expected!&quot;);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p>The same result can be obtained using the <a href="https://docs.rs/url/*/url/struct.Url.html#method.origin"><code>origin</code></a> method as well.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::{Url, Origin, Host};

# error_chain! {
#     foreign_links {
#         UrlParse(url::ParseError);
#     }
# }
#
fn run() -&gt; Result&lt;()&gt; {
    let s = &quot;ftp://rust-lang.org/examples&quot;;

    let url = Url::parse(s)?;

    let expected_scheme = &quot;ftp&quot;.to_owned();
    let expected_host = Host::Domain(&quot;rust-lang.org&quot;.to_owned());
    let expected_port = 21;
    let expected = Origin::Tuple(expected_scheme, expected_host, expected_port);

    let origin = url.origin();
    assert_eq!(origin, expected);
    println!(&quot;The origin is as expected!&quot;);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-url-rm-frag"></a></p>
<a class="header" href="print.html#remove-fragment-identifiers-and-query-pairs-from-a-url" id="remove-fragment-identifiers-and-query-pairs-from-a-url"><h2>Remove fragment identifiers and query pairs from a URL</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>Parses <a href="https://docs.rs/url/*/url/struct.Url.html"><code>Url</code></a> and slices it with <a href="https://docs.rs/url/*/url/enum.Position.html"><code>url::Position</code></a> to strip unneeded URL parts.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::{Url, Position};
#
# error_chain! {
#     foreign_links {
#         UrlParse(url::ParseError);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let parsed = Url::parse(&quot;https://github.com/rust-lang/rust/issues?labels=E-easy&amp;state=open&quot;)?;
    let cleaned: &amp;str = &amp;parsed[..Position::AfterPath];
    println!(&quot;cleaned: {}&quot;, cleaned);
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-url-basic"></a></p>
<a class="header" href="print.html#make-a-http-get-request" id="make-a-http-get-request"><h2>Make a HTTP GET request</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>Parses the supplied URL and makes a synchronous HTTP GET request
with <a href="https://docs.rs/reqwest/*/reqwest/fn.get.html"><code>reqwest::get</code></a>. Prints obtained <a href="https://docs.rs/reqwest/*/reqwest/struct.Response.html"><code>reqwest::Response</code></a>
status and headers subsequently reading HTTP response body into an allocated <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> via <a href="https://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string"><code>read_to_string</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate reqwest;

use std::io::Read;
#
# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#         HttpRequest(reqwest::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let mut res = reqwest::get(&quot;http://httpbin.org/get&quot;)?;
    let mut body = String::new();
    res.read_to_string(&amp;mut body)?;

    println!(&quot;Status: {}&quot;, res.status());
    println!(&quot;Headers:\n{}&quot;, res.headers());
    println!(&quot;Body:\n{}&quot;, body);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-url-download"></a></p>
<a class="header" href="print.html#download-a-file-to-a-temporary-directory" id="download-a-file-to-a-temporary-directory"><h2>Download a file to a temporary directory</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/tempdir/"><img src="https://badge-cache.kominick.com/crates/v/tempdir.svg?label=tempdir" alt="tempdir-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Creates a temporary directory with <a href="https://docs.rs/tempdir/*/tempdir/struct.TempDir.html#method.new"><code>TempDir::new</code></a> and  synchronously downloads
a file over HTTP using <a href="https://docs.rs/reqwest/*/reqwest/fn.get.html"><code>reqwest::get</code></a>.
Creates a target <a href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>File</code></a> with name obtained from <a href="https://docs.rs/reqwest/*/reqwest/struct.Response.html#method.url"><code>Response::url</code></a> within <a href="https://docs.rs/tempdir/*/tempdir/struct.TempDir.html#method.path"><code>TempDir::path</code></a>
and copies downloaded data into it with <a href="https://doc.rust-lang.org/std/io/fn.copy.html"><code>io::copy</code></a>.
The temporary directory is automatically removed on <code>run</code> function return.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate reqwest;
extern crate tempdir;

use std::io::copy;
use std::fs::File;
use tempdir::TempDir;
#
# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#         HttpRequest(reqwest::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    // create a temp dir with prefix &quot;example&quot;
    let tmp_dir = TempDir::new(&quot;example&quot;)?;
    // make HTTP request for remote content
    let target = &quot;https://www.rust-lang.org/logos/rust-logo-512x512.png&quot;;
    let mut response = reqwest::get(target)?;

    let mut dest = {
        // extract target filename from URL
        let fname = response
            .url()
            .path_segments()
            .and_then(|segments| segments.last())
            .and_then(|name| if name.is_empty() { None } else { Some(name) })
            .unwrap_or(&quot;tmp.bin&quot;);

        println!(&quot;file to download: '{}'&quot;, fname);
        let fname = tmp_dir.path().join(fname);
        println!(&quot;will be located under: '{:?}'&quot;, fname);
        // create file with given name inside the temp dir
        File::create(fname)?
    };
    // data is copied into the target file
    copy(&amp;mut response, &amp;mut dest)?;
    // tmp_dir is implicitly removed
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-rest-get"/></p>
<a class="header" href="print.html#query-the-github-api" id="query-the-github-api"><h2>Query the GitHub API</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Queries GitHub <a href="https://developer.github.com/v3/activity/starring/#list-stargazers">stargazers API v3</a>
with <a href="https://docs.rs/reqwest/*/reqwest/fn.get.html"><code>reqwest::get</code></a> to get list of all users who have marked a GitHub project with a star. <a href="https://docs.rs/reqwest/*/reqwest/struct.Response.html"><code>reqwest::Response</code></a> is deserialized with <a href="https://docs.rs/reqwest/*/reqwest/struct.Response.html#method.json"><code>Response::json</code></a> into <code>User</code> objects implementing <a href="https://docs.rs/serde/*/serde/trait.Deserialize.html"><code>serde::Deserialize</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate serde_derive;
extern crate reqwest;

#[derive(Deserialize, Debug)]
struct User {
    login: String,
    id: u32,
    // remaining fields not deserialized for brevity
}
#
# error_chain! {
#     foreign_links {
#         Reqwest(reqwest::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let request_url = format!(&quot;https://api.github.com/repos/{owner}/{repo}/stargazers&quot;,
                              owner = &quot;rust-lang-nursery&quot;,
                              repo = &quot;rust-cookbook&quot;);
    println!(&quot;{}&quot;, request_url);
    let mut response = reqwest::get(&amp;request_url)?;

    let users: Vec&lt;User&gt; = response.json()?;
    println!(&quot;{:?}&quot;, users);
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-rest-head"/></p>
<a class="header" href="print.html#check-if-an-api-resource-exists" id="check-if-an-api-resource-exists"><h2>Check if an API resource exists</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>Query the <a href="https://api.github.com/users">GitHub Users Endpoint</a> using a HEAD request (<a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html#method.head"><code>Client::head</code></a>) and then inspect the
response code to determine success. This is a quick way to query a rest resource without
needing to receive a body. You can also configure the <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html"><code>reqwest::Client</code></a> with <a href="https://docs.rs/reqwest/*/reqwest/struct.ClientBuilder.html#method.timeout"><code>ClientBuilder::timeout</code></a>
which ensures that a request will not last longer than what is passed to the timeout function.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate reqwest;

use std::time::Duration;
use reqwest::ClientBuilder;
#
# error_chain! {
#     foreign_links {
#         Reqwest(reqwest::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let user = &quot;ferris-the-crab&quot;;
    let request_url = format!(&quot;https://api.github.com/users/{}&quot;, user);
    println!(&quot;{}&quot;, request_url);

    // The timeout for the request is set to 5 seconds.
    let timeout = Duration::new(5, 0);

    let client = ClientBuilder::new().timeout(timeout).build()?;
    let response = client.head(&amp;request_url).send()?;

    if response.status().is_success() {
        println!(&quot;{} is a user!&quot;, user);
    } else {
        println!(&quot;{} is not a user!&quot;, user);
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-rest-custom-params"/></p>
<a class="header" href="print.html#set-custom-headers-and-url-parameters-for-a-rest-request" id="set-custom-headers-and-url-parameters-for-a-rest-request"><h2>Set custom headers and URL parameters for a REST request</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/hyper/"><img src="https://badge-cache.kominick.com/crates/v/hyper.svg?label=hyper" alt="hyper-badge" /></a> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>Sets both standard and custom HTTP headers as well as URL parameters
for HTTP GET request. Firstly creates a custom header of type <code>XPoweredBy</code>
with <a href="https://docs.rs/hyper/*/hyper/macro.header.html"><code>hyper::header!</code></a> macro. Secondly calls <a href="https://docs.rs/url/*/url/struct.Url.html#method.parse_with_params"><code>Url::parse_with_params</code></a>
in order to build a complex URL with specified key value pairs.
Lastly sets standard headers <a href="https://docs.rs/hyper/*/hyper/header/struct.UserAgent.html"><code>header::UserAgent</code></a> and <a href="https://docs.rs/hyper/*/hyper/header/struct.Authorization.html"><code>header::Authorization</code></a>
as well as custom one <code>XPoweredBy</code> with <a href="https://docs.rs/reqwest/*/reqwest/struct.RequestBuilder.html#method.header"><code>RequestBuilder::header</code></a> prior to making
the request with <a href="https://docs.rs/reqwest/*/reqwest/struct.RequestBuilder.html#method.send"><code>RequestBuilder::send</code></a>.</p>
<p>The code is run against <a href="http://httpbin.org/headers">http://httpbin.org/headers</a> service which responds with
a JSON dict containing all request headers for easy verification.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate url;
extern crate reqwest;
#[macro_use]
extern crate hyper;
#[macro_use]
extern crate serde_derive;

use std::collections::HashMap;
use url::Url;
use reqwest::Client;
use reqwest::header::{UserAgent, Authorization, Bearer};

// Custom header type
header! { (XPoweredBy, &quot;X-Powered-By&quot;) =&gt; [String] }

// Helper for verification
#[derive(Deserialize, Debug)]
pub struct HeadersEcho {
    pub headers: HashMap&lt;String, String&gt;,
}
#
# error_chain! {
#     foreign_links {
#         Reqwest(reqwest::Error);
#         UrlParse(url::ParseError);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    // Make request to webservice that will respond with JSON dict containing
    // the headders set on HTTP GET request.
    let url = Url::parse_with_params(&quot;http://httpbin.org/headers&quot;,
                                     &amp;[(&quot;lang&quot;, &quot;rust&quot;), (&quot;browser&quot;, &quot;servo&quot;)])?;

    let mut response = Client::new()
        .get(url)
        .header(UserAgent::new(&quot;Rust-test&quot;))
        .header(Authorization(Bearer { token: &quot;DEadBEEfc001cAFeEDEcafBAd&quot;.to_owned() }))
        .header(XPoweredBy(&quot;Guybrush Threepwood&quot;.to_owned()))
        .send()?;

    // JSON response should match the headers set on request
    let out: HeadersEcho = response.json()?;
    assert_eq!(out.headers[&quot;Authorization&quot;],
               &quot;Bearer DEadBEEfc001cAFeEDEcafBAd&quot;);
    assert_eq!(out.headers[&quot;User-Agent&quot;], &quot;Rust-test&quot;);
    assert_eq!(out.headers[&quot;X-Powered-By&quot;], &quot;Guybrush Threepwood&quot;);
    // Response contains full URL used to make the request
    assert_eq!(response.url().as_str(),
               &quot;http://httpbin.org/headers?lang=rust&amp;browser=servo&quot;);

    println!(&quot;{:?}&quot;, out);
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-rest-post"/></p>
<a class="header" href="print.html#create-and-delete-gist-with-github-api" id="create-and-delete-gist-with-github-api"><h2>Create and delete Gist with GitHub API</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Creates a gist with POST request to GitHub <a href="https://developer.github.com/v3/gists/">gists API v3</a> using <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html#method.post"><code>Client::post</code></a> and subsequently removes it with DELETE request using <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html#method.delete"><code>Client::delete</code></a>.</p>
<p>The <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html"><code>reqwest::Client</code></a> is responsible for details of both requests including
URL, body and authentication. POST body comes from <a href="https://docs.rs/serde_json/*/serde_json/macro.json.html"><code>serde_json::json!</code></a> macro
which provides a way to pass an arbitrary JSON body. Call to <a href="https://docs.rs/reqwest/*/reqwest/struct.RequestBuilder.html#method.json"><code>RequestBuilder::json</code></a> sets the request body while <a href="https://docs.rs/reqwest/*/reqwest/struct.RequestBuilder.html#method.basic_auth"><code>RequestBuilder::basic_auth</code></a> handles authentication.
Finally the call to <a href="https://docs.rs/reqwest/*/reqwest/struct.RequestBuilder.html#method.send"><code>RequestBuilder::send</code></a> synchronously executes the requests.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate reqwest;
#[macro_use]
extern crate serde_derive;
#[macro_use]
extern crate serde_json;

use std::env;
use reqwest::Client;
#
# error_chain! {
#     foreign_links {
#         EnvVar(env::VarError);
#         HttpRequest(reqwest::Error);
#     }
# }

#[derive(Deserialize, Debug)]
struct Gist {
    id: String,
    html_url: String,
    // remaining fields not deserialized for brevity
}

fn run() -&gt; Result&lt;()&gt; {
    let gh_user = env::var(&quot;GH_USER&quot;)?;
    let gh_pass = env::var(&quot;GH_PASS&quot;)?;

    // The type `gist_body` is `serde_json::Value`
    let gist_body = json!({
        &quot;description&quot;: &quot;the description for this gist&quot;,
        &quot;public&quot;: true,
        &quot;files&quot;: {
             &quot;main.rs&quot;: {
             &quot;content&quot;: r#&quot;fn main() { println!(&quot;hello world!&quot;);}&quot;#
            }
        }});

    // create the gist
    let request_url = &quot;https://api.github.com/gists&quot;;
    let mut response = Client::new()
        .post(request_url)
        .basic_auth(gh_user.clone(), Some(gh_pass.clone()))
        .json(&amp;gist_body)
        .send()?;

    let gist: Gist = response.json()?;
    println!(&quot;Created {:?}&quot;, gist);

    // delete the gist
    let request_url = format!(&quot;{}/{}&quot;,request_url, gist.id);
    let response = Client::new()
        .delete(&amp;request_url)
        .basic_auth(gh_user, Some(gh_pass))
        .send()?;

    println!(&quot;Gist {} deleted! Status code: {}&quot;,gist.id, response.status());
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p>For the sake of simplicity the example uses <a href="https://tools.ietf.org/html/rfc2617">HTTP Basic Auth</a> in order to
authorize access to <a href="https://developer.github.com/v3/auth/">GitHub API</a>. A more typical use case would be to
employ one of the much more complex <a href="https://oauth.net/getting-started/">OAuth</a> authorization flows.</p>
<p><a name="ex-paginated-api"></a></p>
<a class="header" href="print.html#consume-a-paginated-restful-api" id="consume-a-paginated-restful-api"><h2>Consume a paginated RESTful API</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Wraps a paginated web API in a convenient Rust iterator. The iterator lazily
fetches the next page of results from the remote server as it arrives at the end
of each page.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate serde_derive;
extern crate reqwest;
#
# error_chain! {
#     foreign_links {
#         Reqwest(reqwest::Error);
#     }
# }

#[derive(Deserialize)]
struct ApiResponse {
    dependencies: Vec&lt;Dependency&gt;,
    meta: Meta,
}

// Could capture more fields here if needed
#[derive(Deserialize)]
struct Dependency {
    crate_id: String,
}

#[derive(Deserialize)]
struct Meta {
    total: u32,
}

struct ReverseDependencies {
    crate_id: String,
    dependencies: &lt;Vec&lt;Dependency&gt; as IntoIterator&gt;::IntoIter,
    client: reqwest::Client,
    page: u32,
    per_page: u32,
    total: u32,
}

impl ReverseDependencies {
    fn of(crate_id: &amp;str) -&gt; Result&lt;Self&gt; {
        Ok(ReverseDependencies {
               crate_id: crate_id.to_owned(),
               dependencies: vec![].into_iter(),
               client: reqwest::Client::new(),
               page: 0,
               per_page: 100,
               total: 0,
           })
    }

    fn try_next(&amp;mut self) -&gt; Result&lt;Option&lt;Dependency&gt;&gt; {
        // If the previous page has a dependency that hasn't been looked at.
        if let Some(dep) = self.dependencies.next() {
            return Ok(Some(dep));
        }

        // If there are no more reverse dependencies.
        if self.page &gt; 0 &amp;&amp; self.page * self.per_page &gt;= self.total {
            return Ok(None);
        }

        // Fetch the next page.
        self.page += 1;
        let url = format!(&quot;https://crates.io/api/v1/crates/{}/reverse_dependencies?page={}&amp;per_page={}&quot;,
                          self.crate_id,
                          self.page,
                          self.per_page);

        let response = self.client.get(&amp;url).send()?.json::&lt;ApiResponse&gt;()?;
        self.dependencies = response.dependencies.into_iter();
        self.total = response.meta.total;
        Ok(self.dependencies.next())
    }
}

impl Iterator for ReverseDependencies {
    type Item = Result&lt;Dependency&gt;;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // Some juggling required here because `try_next` returns a result
        // containing an option, while `next` is supposed to return an option
        // containing a result.
        match self.try_next() {
            Ok(Some(dep)) =&gt; Some(Ok(dep)),
            Ok(None) =&gt; None,
            Err(err) =&gt; Some(Err(err)),
        }
    }
}

fn run() -&gt; Result&lt;()&gt; {
    for dep in ReverseDependencies::of(&quot;serde&quot;)? {
        println!(&quot;reverse dependency: {}&quot;, dep?.crate_id);
    }
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-file-post"/></p>
<a class="header" href="print.html#post-a-file-to-paste-rs" id="post-a-file-to-paste-rs"><h2>POST a file to paste-rs.</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>A connection is established to https://paste.rs using <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html"><code>reqwest::Client</code></a>,
following the <a href="https://docs.rs/reqwest/*/reqwest/struct.RequestBuilder.html"><code>reqwest::RequestBuilder</code></a> pattern.  Calling <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html#method.post"><code>Client::post</code></a>
with a URL establishes the destination, <a href="https://docs.rs/reqwest/*/reqwest/struct.RequestBuilder.html#method.body"><code>RequestBuilder::body</code></a> sets the
content to send by reading the file, and <a href="https://docs.rs/reqwest/*/reqwest/struct.RequestBuilder.html#method.send"><code>RequestBuilder::send</code></a> blocks until
the file uploads and the response is received.  The response is read with
<a href="https://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string"><code>read_to_string</code></a>, and finally displayed in the console.</p>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate reqwest;

# #[macro_use]
# extern crate error_chain;
#
use std::fs::File;
use std::io::Read;
use reqwest::Client;
#
# error_chain! {
#     foreign_links {
#         HttpRequest(reqwest::Error);
#         IoError(::std::io::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let paste_api = &quot;https://paste.rs&quot;;
    let file = File::open(&quot;message&quot;)?;

    // blocks until paste.rs returns a response
    let mut response = Client::new().post(paste_api).body(file).send()?;
    let mut response_body = String::new();
    response.read_to_string(&amp;mut response_body)?;
    println!(&quot;Your paste is located at: {}&quot;, response_body);
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-random-port-tcp"></a></p>
<a class="header" href="print.html#listen-on-unused-port-tcpip" id="listen-on-unused-port-tcpip"><h2>Listen on unused port TCP/IP</h2></a>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.25.0-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>In this example, the port is displayed on the console, and the program will
listen until a request is made.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
#
use std::net::{SocketAddrV4, Ipv4Addr, TcpListener};
use std::io::Read;
#
# error_chain! {
#     foreign_links {
#         Io(::std::io::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let loopback = Ipv4Addr::new(127, 0, 0, 1);
    // Assigning port 0 requests the OS to assign a free port
    let socket = SocketAddrV4::new(loopback, 0);
    let listener = TcpListener::bind(socket)?;
    let port = listener.local_addr()?;
    println!(&quot;Listening on {}, access this port to end the program&quot;, port);
    let (mut tcp_stream, addr) = listener.accept()?; //block  until requested
    println!(&quot;Connection received! {:?} is sending data.&quot;, addr);
    let mut input = String::new();
    // read from the socket until connection closed by client, discard byte count.
    let _ = tcp_stream.read_to_string(&amp;mut input)?;
    println!(&quot;{:?} says {}&quot;, addr, input);
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p>The <code>std</code> library is leveraged to make a well formed IP/port with the
<a href="https://doc.rust-lang.org/std/net/struct.SocketAddrV4.html"><code>SocketAddrV4</code></a> and <a href="https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html"><code>Ipv4Addr</code></a> structs.  An unused random port is requested
by passing 0 to <a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html#method.bind"><code>TcpListener::bind</code></a>.  The assigned address is available via
<a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html#method.local_addr"><code>TcpListener::local_addr</code></a>.</p>
<p><a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html#method.accept"><code>TcpListener::accept</code></a> synchronously waits for an incoming connection and
returns a <code>(</code><a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html"><code>TcpStream</code></a>,  <a href="https://doc.rust-lang.org/std/net/struct.SocketAddrV4.html"><code>SocketAddrV4</code></a><code>)</code> representing the request.
Reading on the socket with <a href="https://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string"><code>read_to_string</code></a> will wait until the connection is
closed which can be tested with <code>telnet ip port</code>.  For example, if the program
shows Listening on 127.0.0.1:11500, run</p>
<p><code>telnet 127.0.0.1 11500</code></p>
<p>After sending data in telnet press <code>ctrl-]</code> and type <code>quit</code>.</p>
<p><a name="ex-extract-links-webpage"/></p>
<a class="header" href="print.html#extract-all-links-from-a-webpage-html" id="extract-all-links-from-a-webpage-html"><h2>Extract all links from a webpage HTML</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/select/"><img src="https://badge-cache.kominick.com/crates/v/select.svg?label=select" alt="select-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>Use <a href="https://docs.rs/reqwest/*/reqwest/fn.get.html"><code>reqwest::get</code></a> to perform a HTTP GET request and then use <a href="https://docs.rs/select/*/select/document/struct.Document.html#method.from_read"><code>Document::from_read</code></a> to parse the response into a HTML document.
We can then retrieve all the links from the document by using <a href="https://docs.rs/select/*/select/document/struct.Document.html#method.find"><code>find</code></a> with the criteria of the <a href="https://docs.rs/select/*/select/predicate/struct.Name.html"><code>Name</code></a> being &quot;a&quot;.
This returns a <a href="https://docs.rs/select/*/select/selection/struct.Selection.html"><code>Selection</code></a> that we <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.filter_map"><code>filter_map</code></a> on to retrieve the urls from links that have the &quot;href&quot; <a href="https://docs.rs/select/*/select/node/struct.Node.html#method.attr"><code>attr</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate reqwest;
extern crate select;

use select::document::Document;
use select::predicate::Name;
#
# error_chain! {
#    foreign_links {
#        ReqError(reqwest::Error);
#        IoError(std::io::Error);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let res = reqwest::get(&quot;https://www.rust-lang.org/en-US/&quot;)?;

    Document::from_read(res)?
        .find(Name(&quot;a&quot;))
        .filter_map(|n| n.attr(&quot;href&quot;))
        .for_each(|x| println!(&quot;{}&quot;, x));

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-check-broken-links"/></p>
<a class="header" href="print.html#check-a-webpage-for-broken-links" id="check-a-webpage-for-broken-links"><h2>Check a webpage for broken links</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/select/"><img src="https://badge-cache.kominick.com/crates/v/select.svg?label=select" alt="select-badge" /></a> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>We call &quot;get_base_url&quot; to retrieve the base URL. If the document has a &quot;base&quot; tag, we get the &quot;href&quot; <a href="https://docs.rs/select/*/select/node/struct.Node.html#method.attr"><code>attr</code></a> from the first occurrence of the &quot;base&quot; tag. This is then used as the base URL. Otherwise, we can use <a href="https://docs.rs/url/*/url/enum.Position.html#variant.BeforePath"><code>Position::BeforePath</code></a> with the original URL to get the base of that URL.</p>
<p>We iterate through all the links in the document and get the absolute URL for each (using <a href="https://docs.rs/url/*/url/struct.ParseOptions.html"><code>url::ParseOptions</code></a> and <a href="https://docs.rs/url/*/url/struct.Url.html#method.parse"><code>Url::parse</code></a>). We then filter these so that we can report which links are broken.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate reqwest;
extern crate select;
extern crate url;

use std::collections::HashSet;

use url::{Url, Position};
use reqwest::StatusCode;
use select::document::Document;
use select::predicate::Name;
#
# error_chain! {
#   foreign_links {
#       ReqError(reqwest::Error);
#       IoError(std::io::Error);
#       UrlParseError(url::ParseError);
#   }
# }

fn get_base_url(url: &amp;Url, doc: &amp;Document) -&gt; Result&lt;Url&gt; {
    let base_tag_href = doc.find(Name(&quot;base&quot;)).filter_map(|n| n.attr(&quot;href&quot;)).nth(0);

    let base_url = base_tag_href.map_or_else(
        || Url::parse(&amp;url[..Position::BeforePath]),
        Url::parse,
    )?;

    Ok(base_url)
}

fn check_link(url: &amp;Url) -&gt; Result&lt;bool&gt; {
    let res = reqwest::get(url.as_ref())?;

    Ok(res.status() != StatusCode::NotFound)
}

fn run() -&gt; Result&lt;()&gt; {
    let url = Url::parse(&quot;https://www.rust-lang.org/en-US/&quot;)?;

    let res = reqwest::get(url.as_ref())?;
    let document = Document::from_read(res)?;

    let base_url = get_base_url(&amp;url, &amp;document)?;

    let base_parser = Url::options().base_url(Some(&amp;base_url));

    let links: HashSet&lt;Url&gt; = document
        .find(Name(&quot;a&quot;))
        .filter_map(|n| n.attr(&quot;href&quot;))
        .filter_map(|link| base_parser.parse(link).ok())
        .collect();

    links
        .iter()
        .filter(|link| check_link(link).ok() == Some(false))
        .for_each(|x| println!(&quot;{} is broken.&quot;, x));

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-extract-mediawiki-links"/></p>
<a class="header" href="print.html#extract-all-unique-links-from-a-mediawiki-markup" id="extract-all-unique-links-from-a-mediawiki-markup"><h2>Extract all unique links from a MediaWiki markup</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>Pull the source of a MediaWiki page using <a href="https://docs.rs/reqwest/*/reqwest/fn.get.html"><code>reqwest::get</code></a> and then
look for all entries of internal and external links with
<a href="https://doc.rust-lang.org/regex/*/regex/struct.Regex.html#method.captures_iter"><code>Regex::captures_iter</code></a>. Using <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>Cow</code></a> avoids excessive <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> allocations.</p>
<p>MediaWiki link syntax is described <a href="https://www.mediawiki.org/wiki/Help:Links">here</a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate lazy_static;
extern crate reqwest;
extern crate regex;

use std::io::Read;
use std::collections::HashSet;
use std::borrow::Cow;
use regex::Regex;

# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#         Reqwest(reqwest::Error);
#         Regex(regex::Error);
#     }
# }
#
fn extract_links(content: &amp;str) -&gt; Result&lt;HashSet&lt;Cow&lt;str&gt;&gt;&gt; {
    lazy_static! {
        static ref WIKI_REGEX: Regex =
            Regex::new(r&quot;(?x)
                \[\[(?P&lt;internal&gt;[^\[\]|]*)[^\[\]]*\]\]    # internal links
                |
                (url=|URL\||\[)(?P&lt;external&gt;http.*?)[ \|}] # external links
            &quot;).unwrap();
    }

    let links: HashSet&lt;_&gt; = WIKI_REGEX
        .captures_iter(content)
        .map(|c| match (c.name(&quot;internal&quot;), c.name(&quot;external&quot;)) {
            (Some(val), None) =&gt; Cow::from(val.as_str().to_lowercase()),
            (None, Some(val)) =&gt; Cow::from(val.as_str()),
            _ =&gt; unreachable!(),
        })
        .collect();

    Ok(links)
}

fn run() -&gt; Result&lt;()&gt; {
    let mut content = String::new();
    reqwest::get(
        &quot;https://en.wikipedia.org/w/index.php?title=Rust_(programming_language)&amp;action=raw&quot;,
    )?
        .read_to_string(&amp;mut content)?;

    println!(&quot;{:#?}&quot;, extract_links(&amp;content)?);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-progress-with-range"/></p>
<a class="header" href="print.html#make-a-partial-download-with-http-range-headers" id="make-a-partial-download-with-http-range-headers"><h2>Make a partial download with HTTP range headers</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>Uses <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html#method.head"><code>reqwest::Client::head</code></a> to get the content-length and validate if the server sets the header
<a href="https://docs.rs/reqwest/*/reqwest/header/struct.ContentRange.html"><code>reqwest::header::ContentRange</code></a>, required to confirm the support of partial downloads.</p>
<p>If supported, downloads the content using <a href="https://docs.rs/reqwest/*/reqwest/fn.get.html"><code>reqwest::get</code></a>, setting the <a href="https://docs.rs/reqwest/*/reqwest/header/enum.Range.html"><code>reqwest::header::Range</code></a>
to do partial downloads printing basic progress messages.
in chunks of 10240 bytes</p>
<p>Range header is defined in <a href="https://tools.ietf.org/html/rfc7233#section-3.1">RFC7233</a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate reqwest;

use std::fs::File;
use reqwest::header::{ContentRange, ContentRangeSpec, Range};
use reqwest::StatusCode;
#
# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#         Reqwest(reqwest::Error);
#     }
# }
#
# struct PartialRangeIter {
#     start: u64,
#     end: u64,
#     buffer_size: u32,
# }
#
# impl PartialRangeIter {
#     pub fn new(content_range: &amp;ContentRangeSpec, buffer_size: u32) -&gt; Result&lt;Self&gt; {
#         if buffer_size == 0 {
#             Err(&quot;invalid buffer_size, give a value greater than zero.&quot;)?;
#         }
#
#         match *content_range {
#             ContentRangeSpec::Bytes { range: Some(range), .. } =&gt; Ok(PartialRangeIter {
#                 start: range.0,
#                 end: range.1,
#                 buffer_size,
#             }),
#             _ =&gt; Err(&quot;invalid range specification&quot;)?,
#         }
#     }
# }
#
# impl Iterator for PartialRangeIter {
#     type Item = Range;
#
#     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
#         if self.start &gt; self.end {
#             None
#         } else {
#             let prev_start = self.start;
#             self.start += std::cmp::min(self.buffer_size as u64, self.end - self.start + 1);
#             Some(Range::bytes(prev_start, self.start - 1))
#         }
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    // For the purpose of this example only a small download of 102400 bytes
    // with chunk size of 10240 bytes is used.
    let url = &quot;https://httpbin.org/range/102400?duration=2&quot;;
    const CHUNK_SIZE: u32 = 10240;

    let client = reqwest::Client::new();
    let response = client.head(url).send()?;
    let range = response.headers().get::&lt;ContentRange&gt;().ok_or(
        &quot;response doesn't include the expected ranges&quot;,
    )?;

    let mut output_file = File::create(&quot;download.bin&quot;)?;

    println!(&quot;starting download...&quot;);
    for range in PartialRangeIter::new(range, CHUNK_SIZE)? {

        println!(&quot;range {:?}&quot;, range);
        let mut response = client.get(url).header(range).send()?;

        let status = response.status();
        if !(status == StatusCode::Ok || status == StatusCode::PartialContent) {
            bail!(&quot;Unexpected server response: {}&quot;, status)
        }

        std::io::copy(&amp;mut response, &amp;mut output_file)?;
    }

    println!(&quot;Finished with success!&quot;);
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-handle-rate-limited-api"/></p>
<a class="header" href="print.html#handle-a-rate-limited-api" id="handle-a-rate-limited-api"><h2>Handle a rate-limited API</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/hyper/"><img src="https://badge-cache.kominick.com/crates/v/hyper.svg?label=hyper" alt="hyper-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>This example uses the <a href="https://developer.github.com/v3/#rate-limiting">GitHub API - Rate limiting</a>, as an example of how to
handle remote server errors.  This example uses the <a href="https://docs.rs/hyper/*/hyper/macro.header.html"><code>hyper::header!</code></a> macro
to parse the response header and checks for <a href="https://docs.rs/reqwest/*/reqwest/enum.StatusCode.html#variant.Forbidden"><code>reqwest::StatusCode::Forbidden</code></a>.
If the response exceeds the rate limit, the example waits and retries.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate hyper;
extern crate reqwest;

use std::time::{Duration, UNIX_EPOCH};
use std::thread;
use reqwest::StatusCode;
#
# error_chain! {
#    foreign_links {
#        Io(std::io::Error);
#        Time(std::time::SystemTimeError);
#        Reqwest(reqwest::Error);
#    }
# }

header! { (XRateLimitLimit, &quot;X-RateLimit-Limit&quot;) =&gt; [usize] }
header! { (XRateLimitRemaining, &quot;X-RateLimit-Remaining&quot;) =&gt; [usize] }
header! { (XRateLimitReset, &quot;X-RateLimit-Reset&quot;) =&gt; [u64] }

fn run() -&gt; Result&lt;()&gt; {
    let url = &quot;https://api.github.com/users/rust-lang-nursery &quot;;
    let client = reqwest::Client::new();
    let response = client.get(url).send()?;

    let rate_limit = response.headers().get::&lt;XRateLimitLimit&gt;().ok_or(
        &quot;response doesn't include the expected X-RateLimit-Limit header&quot;,
    )?;

    let rate_remaining = response.headers().get::&lt;XRateLimitRemaining&gt;().ok_or(
        &quot;response doesn't include the expected X-RateLimit-Remaining header&quot;,
    )?;

    let rate_reset_at = response.headers().get::&lt;XRateLimitReset&gt;().ok_or(
        &quot;response doesn't include the expected X-RateLimit-Reset header&quot;,
    )?;

    let rate_reset_within = Duration::from_secs(**rate_reset_at) - UNIX_EPOCH.elapsed()?;

    if response.status() == StatusCode::Forbidden &amp;&amp; **rate_remaining == 0 {
        println!(&quot;Sleeping for {} seconds.&quot;, rate_reset_within.as_secs());
        thread::sleep(rate_reset_within);
        return run();
    }
    else {
        println!(
            &quot;Rate limit is currently {}/{}, the reset of this limit will be within {} seconds.&quot;,
            **rate_remaining,
            **rate_limit,
            rate_reset_within.as_secs(),
        );
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-http-response-mime-type"/></p>
<a class="header" href="print.html#parse-the-mime-type-of-a-http-response" id="parse-the-mime-type-of-a-http-response"><h2>Parse the MIME type of a HTTP response</h2></a>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/mime/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=mime" alt="mime-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>When receiving a HTTP reponse from <em>reqwest</em> the <a href="https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME type</a> or media type can be
found in the <a href="https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type">Content-Type</a> header. The header can be looked up by using
<a href="https://docs.rs/reqwest/*/reqwest/header/struct.Headers.html#method.get"><code>reqwest::Headers::get</code></a> with the generic type <a href="https://docs.rs/reqwest/*/reqwest/header/struct.ContentType.html"><code>reqwest::header::ContentType</code></a>.
Because <code>ContentType</code> implements Deref with <a href="https://docs.rs/mime/*/mime/struct.Mime.html"><code>mime::Mime</code></a> as a target, parts of the
MIME type can be obtained directly.</p>
<p>The <em>Mime</em> crate also has some, commonly used, predefined MIME types. These can be
used for comparison and matching on the types. <em>Reqwest</em> also exports the <em>mime</em>
crate, which can be found in the <code>reqwest::mime</code> module.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate mime;
extern crate reqwest;

use reqwest::header::ContentType;
#
# error_chain! {
#    foreign_links {
#        Reqwest(reqwest::Error);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let response = reqwest::get(&quot;https://www.rust-lang.org/logos/rust-logo-32x32.png&quot;)?;
    let headers = response.headers();

    match headers.get::&lt;ContentType&gt;() {
        None =&gt; {
            println!(&quot;The response does not contain a Content-Type header.&quot;);
        }
        Some(content_type) =&gt; {
            let media_type = match (content_type.type_(), content_type.subtype()) {
                (mime::TEXT, mime::HTML) =&gt; &quot;a HTML document&quot;,
                (mime::TEXT, _) =&gt; &quot;a text document&quot;,
                (mime::IMAGE, mime::PNG) =&gt; &quot;a PNG image&quot;,
                (mime::IMAGE, _) =&gt; &quot;an image&quot;,
                _ =&gt; &quot;neither text nor image&quot;,
            };

            println!(&quot;The reponse contains {}.&quot;, media_type);
        }
    };

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<!-- API Reference -->
<!-- Other Reference -->
<a class="header" href="print.html#application-development" id="application-development"><h1>Application development</h1></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="print.html#ex-clap-basic">Parse command line arguments</a> </td><td> <a href="https://docs.rs/clap/"><img src="https://badge-cache.kominick.com/crates/v/clap.svg?label=clap" alt="clap-badge" /></a> </td><td> <a href="https://crates.io/categories/command-line-interface"><img src="https://badge-cache.kominick.com/badge/command_line--x.svg?style=social" alt="cat-command-line-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-tar-decompress">Decompress a tarball</a> </td><td> <a href="https://docs.rs/flate2/"><img src="https://badge-cache.kominick.com/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://badge-cache.kominick.com/crates/v/tar.svg?label=tar" alt="tar-badge" /></a> </td><td> <a href="https://crates.io/categories/compression"><img src="https://badge-cache.kominick.com/badge/compression--x.svg?style=social" alt="cat-compression-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-tar-compress">Compress a directory into a tarball</a> </td><td> <a href="https://docs.rs/flate2/"><img src="https://badge-cache.kominick.com/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://badge-cache.kominick.com/crates/v/tar.svg?label=tar" alt="tar-badge" /></a> </td><td> <a href="https://crates.io/categories/compression"><img src="https://badge-cache.kominick.com/badge/compression--x.svg?style=social" alt="cat-compression-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-tar-strip-prefix">Decompress a tarball while removing a prefix from the paths</a> </td><td> <a href="https://docs.rs/flate2/"><img src="https://badge-cache.kominick.com/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://badge-cache.kominick.com/crates/v/tar.svg?label=tar" alt="tar-badge" /></a> </td><td> <a href="https://crates.io/categories/compression"><img src="https://badge-cache.kominick.com/badge/compression--x.svg?style=social" alt="cat-compression-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-avoid-read-write">Avoid writing and reading from a same file</a> </td><td> <a href="https://docs.rs/same-file/"><img src="https://badge-cache.kominick.com/crates/v/same_file.svg?label=same_file" alt="same_file-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-find-file-loops">Find loops for a given path</a> </td><td> <a href="https://docs.rs/same-file/"><img src="https://badge-cache.kominick.com/crates/v/same_file.svg?label=same_file" alt="same_file-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-dedup-filenames">Recursively find duplicate file names</a> </td><td> <a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-file-predicate">Recursively find all files with given predicate</a> </td><td> <a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-file-skip-dot">Traverse directories while skipping dotfiles</a> </td><td> <a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-file-sizes">Recursively calculate file sizes at given depth</a> </td><td> <a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-glob-recursive">Find all png files recursively</a> </td><td> <a href="https://docs.rs/glob/"><img src="https://badge-cache.kominick.com/crates/v/glob.svg?label=glob" alt="glob-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-glob-with">Find all files with given pattern ignoring filename case</a> </td><td> <a href="https://docs.rs/glob/"><img src="https://badge-cache.kominick.com/crates/v/glob.svg?label=glob" alt="glob-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-semver-increment">Parse and increment a version string</a> </td><td> <a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a> </td><td> <a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-semver-complex">Parse a complex version string</a> </td><td> <a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a> </td><td> <a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-semver-prerelease">Check if given version is pre-release</a> </td><td> <a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a> </td><td> <a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-semver-latest">Find the latest version satisfying given range</a> </td><td> <a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a> </td><td> <a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-semver-command">Check external command version for compatibility</a> </td><td> <a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a> </td><td> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></td></tr>
</tbody></table>
<p><a name="ex-clap-basic"></a></p>
<a class="header" href="print.html#parse-command-line-arguments" id="parse-command-line-arguments"><h2>Parse command line arguments</h2></a>
<p><a href="https://docs.rs/clap/"><img src="https://badge-cache.kominick.com/crates/v/clap.svg?label=clap" alt="clap-badge" /></a> <a href="https://crates.io/categories/command-line-interface"><img src="https://badge-cache.kominick.com/badge/command_line--x.svg?style=social" alt="cat-command-line-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust">extern crate clap;

use clap::{Arg, App};

fn main() {
    // Define command line arguments.
    let matches = App::new(&quot;My Test Program&quot;)
        .version(&quot;0.1.0&quot;)
        .author(&quot;Hackerman Jones &lt;hckrmnjones@hack.gov&gt;&quot;)
        .about(&quot;Teaches argument parsing&quot;)
        .arg(Arg::with_name(&quot;file&quot;)
                 .short(&quot;f&quot;)
                 .long(&quot;file&quot;)
                 .takes_value(true)
                 .help(&quot;A cool file&quot;))
        .arg(Arg::with_name(&quot;num&quot;)
                 .short(&quot;n&quot;)
                 .long(&quot;number&quot;)
                 .takes_value(true)
                 .help(&quot;Five less than your favorite number&quot;))
        .get_matches();

    // Get value for file, or default to 'input.txt'.
    let myfile = matches.value_of(&quot;file&quot;).unwrap_or(&quot;input.txt&quot;);
    println!(&quot;The file passed is: {}&quot;, myfile);

    // Get value for num if present, and try parsing it as i32.
    let num_str = matches.value_of(&quot;num&quot;);
    match num_str {
        None =&gt; println!(&quot;No idea what your favorite number is.&quot;),
        Some(s) =&gt; {
            match s.parse::&lt;i32&gt;() {
                Ok(n) =&gt; println!(&quot;Your favorite number must be {}.&quot;, n + 5),
                Err(_) =&gt; println!(&quot;That's not a number! {}&quot;, s),
            }
        }
    }
}
</code></pre></pre>
<p>The <code>clap</code> crate is a simple-to-use, efficient, and full-featured library for
parsing command line arguments and subcommands when writing console/terminal
applications.</p>
<p>The application can describe the structure of its command-line interface using
<code>clap</code>'s builder style. The <a href="https://docs.rs/clap/">documentation</a> gives two other possible ways to
instantiate an application.</p>
<p>In the builder style, <code>with_name</code> is the unique identifier that <code>value_of</code> will
use to retrieve the value passed. The <code>short</code> and <code>long</code> options control the
flag the user will be expected to type; short flags look like <code>-f</code> and long
flags look like <code>--file</code>.</p>
<p>Usage information is generated by <code>clap</code>. The usage for the example application
looks like this.</p>
<pre><code>My Test Program 0.1.0
Hackerman Jones &lt;hckrmnjones@hack.gov&gt;
Teaches argument parsing

USAGE:
    testing [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -f, --file &lt;file&gt;     A cool file
    -n, --number &lt;num&gt;    Five less than your favorite number
</code></pre>
<p>We can test the application by running a command like the following.</p>
<pre><code>$ cargo run -- -f myfile.txt -n 251
</code></pre>
<p>The output is:</p>
<pre><code>The file passed is: myfile.txt
Your favorite number must be 256.
</code></pre>
<p><a name="ex-tar-decompress"></a></p>
<a class="header" href="print.html#decompress-a-tarball" id="decompress-a-tarball"><h2>Decompress a tarball</h2></a>
<p><a href="https://docs.rs/flate2/"><img src="https://badge-cache.kominick.com/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://badge-cache.kominick.com/crates/v/tar.svg?label=tar" alt="tar-badge" /></a> <a href="https://crates.io/categories/compression"><img src="https://badge-cache.kominick.com/badge/compression--x.svg?style=social" alt="cat-compression-badge" /></a></p>
<p>Decompress (<a href="https://docs.rs/flate2/*/flate2/read/struct.GzDecoder.html"><code>GzDecoder</code></a>) and
extract (<a href="https://docs.rs/tar/*/tar/struct.Archive.html#method.unpack"><code>Archive::unpack</code></a>) all files from a compressed tarball
named <code>archive.tar.gz</code> located in the current working directory.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate flate2;
extern crate tar;

use std::fs::File;
use flate2::read::GzDecoder;
use tar::Archive;
#
# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let path = &quot;archive.tar.gz&quot;;

    // Open a compressed tarball
    let tar_gz = File::open(path)?;
    // Decompress it
    let tar = GzDecoder::new(tar_gz);
    // Load the archive from the tarball
    let mut archive = Archive::new(tar);
    // Unpack the archive inside current working directory
    archive.unpack(&quot;.&quot;)?;

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-tar-compress"></a></p>
<a class="header" href="print.html#compress-a-directory-into-tarball" id="compress-a-directory-into-tarball"><h2>Compress a directory into tarball</h2></a>
<p><a href="https://docs.rs/flate2/"><img src="https://badge-cache.kominick.com/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://badge-cache.kominick.com/crates/v/tar.svg?label=tar" alt="tar-badge" /></a> <a href="https://crates.io/categories/compression"><img src="https://badge-cache.kominick.com/badge/compression--x.svg?style=social" alt="cat-compression-badge" /></a></p>
<p>Compresses <code>/var/log</code> directory into <code>archive.tar.gz</code>.</p>
<p>Creates a <a href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>File</code></a> wrapped in <a href="https://docs.rs/flate2/*/flate2/write/struct.GzEncoder.html"><code>GzEncoder</code></a>
and <a href="https://docs.rs/tar/*/tar/struct.Builder.html"><code>tar::Builder</code></a>. </br>Adds contents of <code>/var/log</code> directory recursively into the archive
under <code>backup/logs</code>path with <a href="https://docs.rs/tar/*/tar/struct.Builder.html#method.append_dir_all"><code>Builder::append_dir_all</code></a>.
<a href="https://docs.rs/flate2/*/flate2/write/struct.GzEncoder.html"><code>GzEncoder</code></a> is responsible for transparently compressing the
data prior to writing it into <code>archive.tar.gz</code>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate tar;
extern crate flate2;
#
# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#     }
# }

use std::fs::File;
use flate2::Compression;
use flate2::write::GzEncoder;

fn run() -&gt; Result&lt;()&gt; {
    let tar_gz = File::create(&quot;archive.tar.gz&quot;)?;
    let enc = GzEncoder::new(tar_gz, Compression::default());
    let mut tar = tar::Builder::new(enc);
    tar.append_dir_all(&quot;backup/logs&quot;, &quot;/var/log&quot;)?;
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-tar-strip-prefix"></a></p>
<a class="header" href="print.html#decompress-a-tarball-while-removing-a-prefix-from-the-paths" id="decompress-a-tarball-while-removing-a-prefix-from-the-paths"><h2>Decompress a tarball while removing a prefix from the paths</h2></a>
<p><a href="https://docs.rs/flate2/"><img src="https://badge-cache.kominick.com/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://badge-cache.kominick.com/crates/v/tar.svg?label=tar" alt="tar-badge" /></a> <a href="https://crates.io/categories/compression"><img src="https://badge-cache.kominick.com/badge/compression--x.svg?style=social" alt="cat-compression-badge" /></a></p>
<p>Strip a path prefix from the entries of a tarball before unpacking them.</p>
<p>We iterate over the <a href="https://docs.rs/tar/*/tar/struct.Archive.html#method.entries"><code>Archive::entries</code></a>, using <a href="https://doc.rust-lang.org/std/path/struct.Path.html#method.strip_prefix"><code>Path::strip_prefix</code></a> to remove
the specified path prefix (<code>bundle/logs</code>) before extracting the <a href="https://docs.rs/tar/*/tar/struct.Entry.html"><code>tar::Entry</code></a>
via <a href="https://docs.rs/tar/*/tar/struct.Entry.html#method.unpack"><code>Entry::unpack</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate flate2;
extern crate tar;
#
# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#         StripPrefixError(::std::path::StripPrefixError);
#     }
# }

use std::fs::File;
use std::path::PathBuf;
use flate2::read::GzDecoder;
use tar::Archive;

fn run() -&gt; Result&lt;()&gt; {
    let file = File::open(&quot;archive.tar.gz&quot;)?;
    let mut archive = Archive::new(GzDecoder::new(file));
    let prefix = &quot;bundle/logs&quot;;

    println!(&quot;Extracted the following files:&quot;);
    archive
        .entries()?
        .filter_map(|e| e.ok())
        .map(|mut entry| -&gt; Result&lt;PathBuf&gt; {
            // Need to get owned data to break the borrow loop
            let path = entry.path()?.strip_prefix(prefix)?.to_owned();
            entry.unpack(&amp;path)?;
            Ok(path)
        })
        .filter_map(|e| e.ok())
        .for_each(|x| println!(&quot;&gt; {}&quot;, x.display()));

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-avoid-read-write"></a></p>
<a class="header" href="print.html#avoid-writing-and-reading-from-a-same-file" id="avoid-writing-and-reading-from-a-same-file"><h2>Avoid writing and reading from a same file</h2></a>
<p><a href="https://docs.rs/same-file/"><img src="https://badge-cache.kominick.com/crates/v/same_file.svg?label=same_file" alt="same_file-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Use <a href="https://docs.rs/same-file/*/same_file/struct.Handle.html"><code>same_file::Handle</code></a> to a file that can be tested for equality with
other handles. In this example, the handles of file to be read from and
to be written to are tested for equality.</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>will display the contents of the file if the two files are not same and</p>
<pre><code class="language-bash">cargo run &gt;&gt; ./new.txt
</code></pre>
<p>will display the error (because the two files are same).</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate same_file;

use same_file::Handle;
use std::path::Path;
use std::fs::File;
use std::io::{BufRead, BufReader};
#
# error_chain! {
#     foreign_links {
#          IOError(::std::io::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let path_to_read = Path::new(&quot;new.txt&quot;);

    let stdout_handle = Handle::stdout()?;
    let handle = Handle::from_path(path_to_read)?;

    if stdout_handle == handle {
        bail!(&quot;You are reading and writing to the same file&quot;);
    } else {
        let file = File::open(&amp;path_to_read)?;
        let file = BufReader::new(file);
        for (num, line) in file.lines().enumerate() {
            println!(&quot;{} : {}&quot;, num, line?.to_uppercase());
        }
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-find-file-loops"></a></p>
<a class="header" href="print.html#find-loops-for-a-given-path" id="find-loops-for-a-given-path"><h2>Find loops for a given path</h2></a>
<p><a href="https://docs.rs/same-file/"><img src="https://badge-cache.kominick.com/crates/v/same_file.svg?label=same_file" alt="same_file-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Use <a href="https://docs.rs/same-file/*/same_file/fn.is_same_file.html#method.is_same_file"><code>same_file::is_same_file</code></a> to detect loops for a given path.
For example, a loop could be created on a Unix system via symlinks:</p>
<pre><code class="language-bash">mkdir -p /tmp/foo/bar/baz
ln -s /tmp/foo/  /tmp/foo/bar/baz/qux
</code></pre>
<p>Then, running the following would assert that there exists a loop.</p>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate same_file;

use std::io;
use std::path::{Path, PathBuf};
use same_file::is_same_file;

// Check this path against all of its parents
fn contains_loop&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;Option&lt;(PathBuf, PathBuf)&gt;&gt; {
    let path = path.as_ref();
    let mut path_buf = path.to_path_buf();
    while path_buf.pop() {
        if is_same_file(&amp;path_buf, path)? {
            return Ok(Some((path_buf, path.to_path_buf())));
        } else if let Some(looped_paths) = contains_loop(&amp;path_buf)? {
            return Ok(Some(looped_paths));
        }
    }
    return Ok(None);
}

fn main() {
    assert_eq!(
        contains_loop(&quot;/tmp/foo/bar/baz/qux/bar/baz&quot;).unwrap(),
        Some((
            PathBuf::from(&quot;/tmp/foo&quot;),
            PathBuf::from(&quot;/tmp/foo/bar/baz/qux&quot;)
        ))
    );
}
</code></pre></pre>
<p><a name="ex-dedup-filenames"></a></p>
<a class="header" href="print.html#recursively-find-duplicate-file-names" id="recursively-find-duplicate-file-names"><h2>Recursively find duplicate file names</h2></a>
<p><a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Find recursively in the current directory duplicate filenames,
printing them only once.</p>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate walkdir;

use std::collections::HashMap;
use walkdir::WalkDir;

fn main() {
    // Counters indexed by filenames
    let mut filenames = HashMap::new();

    // List recusively all files in the current directory filtering out
    // directories and files not accessible (permission denied)
    for entry in WalkDir::new(&quot;.&quot;)
            .into_iter()
            .filter_map(Result::ok)
            .filter(|e| !e.file_type().is_dir()) {
        // Get entry's filename
        let f_name = String::from(entry.file_name().to_string_lossy());
        // Get or initialize the counter
        let counter = filenames.entry(f_name.clone()).or_insert(0);
        // Update the counter
        *counter += 1;

        if *counter == 2 {
            println!(&quot;{}&quot;, f_name);
        }
    }
}
</code></pre></pre>
<p><a name="ex-file-predicate"></a></p>
<a class="header" href="print.html#recursively-find-all-files-with-given-predicate" id="recursively-find-all-files-with-given-predicate"><h2>Recursively find all files with given predicate</h2></a>
<p><a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Find JSON files modified within the last day in the current directory.
Using <a href="https://docs.rs/walkdir/*/walkdir/struct.WalkDir.html#method.follow_links"><code>follow_links</code></a> ensures symbolic links are followed like they were
normal directories and files.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate walkdir;

use walkdir::WalkDir;
#
# error_chain! {
#     foreign_links {
#         WalkDir(walkdir::Error);
#         Io(std::io::Error);
#         SystemTime(std::time::SystemTimeError);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    // List recusively all accessible files in the current directory
    for entry in WalkDir::new(&quot;.&quot;)
            .follow_links(true)
            .into_iter()
            .filter_map(|e| e.ok()) {
        // Get entry's filename
        let f_name = entry.file_name().to_string_lossy();
        // Get entry's modified time
        let sec = entry.metadata()?.modified()?;

        // Print JSON files modified within the last day
        if f_name.ends_with(&quot;.json&quot;) &amp;&amp; sec.elapsed()?.as_secs() &lt; 86400 {
            println!(&quot;{}&quot;, f_name);
        }
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-file-skip-dot"></a></p>
<a class="header" href="print.html#traverse-directories-while-skipping-dotfiles" id="traverse-directories-while-skipping-dotfiles"><h2>Traverse directories while skipping dotfiles</h2></a>
<p><a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Uses <a href="https://docs.rs/walkdir/*/walkdir/struct.IntoIter.html#method.filter_entry"><code>filter_entry</code></a> to descend recursively into entries passing the <code>is_not_hidden</code> predicate thus skipping hidden files and directories whereas <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter"><code>Iterator::filter</code></a> would be applied to each <a href="https://docs.rs/walkdir/*/walkdir/struct.DirEntry.html"><code>WalkDir::DirEntry</code></a> even if the parent is a hidden directory.</p>
<p>Root dir <code>&quot;.&quot;</code> is yielded due to <a href="https://docs.rs/walkdir/*/walkdir/struct.DirEntry.html#method.depth"><code>WalkDir::depth</code></a> usage in <code>is_not_hidden</code> predicate.</p>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate walkdir;

use walkdir::{DirEntry, WalkDir};

fn is_not_hidden(entry: &amp;DirEntry) -&gt; bool {
    entry
         .file_name()
         .to_str()
         .map(|s| entry.depth() == 0 || !s.starts_with(&quot;.&quot;))
         .unwrap_or(false)
}

fn main() {
    WalkDir::new(&quot;.&quot;)
        .into_iter()
        .filter_entry(|e| is_not_hidden(e))
        .filter_map(|v| v.ok())
        .for_each(|x| println!(&quot;{}&quot;, x.path().display()));
}
</code></pre></pre>
<p><a name="ex-file-sizes"></a></p>
<a class="header" href="print.html#recursively-calculate-file-sizes-at-given-depth" id="recursively-calculate-file-sizes-at-given-depth"><h2>Recursively calculate file sizes at given depth</h2></a>
<p><a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Recursion depth can be flexibly set by <a href="https://docs.rs/walkdir/*/walkdir/struct.WalkDir.html#method.min_depth"><code>WalkDir::min_depth</code></a> &amp; <a href="https://docs.rs/walkdir/*/walkdir/struct.WalkDir.html#method.max_depth"><code>WalkDir::max_depth</code></a> methods.
In this example we sum all file sizes to 3 subfolders depth, ignoring files in the root folder
at the same time.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate walkdir;

use walkdir::WalkDir;

fn main() {
    let total_size = WalkDir::new(&quot;.&quot;)
        .min_depth(1)
        .max_depth(3)
        .into_iter()
        .filter_map(|entry| entry.ok()) // Files, we have access to
        .filter_map(|entry| entry.metadata().ok()) // Get metadata
        .filter(|metadata| metadata.is_file()) // Filter out directories
        .fold(0, |acc, m| acc + m.len()); // Accumulate sizes

    println!(&quot;Total size: {} bytes.&quot;, total_size);
}
</code></pre></pre>
<p><a name="ex-glob-recursive"></a></p>
<a class="header" href="print.html#find-all-png-files-recursively" id="find-all-png-files-recursively"><h2>Find all png files recursively</h2></a>
<p><a href="https://docs.rs/glob/"><img src="https://badge-cache.kominick.com/crates/v/glob.svg?label=glob" alt="glob-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Recursively find all PNG files in the current directory.
In this case, the <code>**</code> pattern matches the current directory and all subdirectories.</p>
<p>You can also use the <code>**</code> pattern for any directory, not just the current one.
For example, <code>/media/**/*.png</code> would match all PNGs in <code>media</code> and it's subdirectories.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate glob;

use glob::glob;
#
# error_chain! {
#     foreign_links {
#         Glob(glob::GlobError);
#         Pattern(glob::PatternError);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    for entry in glob(&quot;**/*.png&quot;)? {
        println!(&quot;{}&quot;, entry?.display());
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-glob-with"></a></p>
<a class="header" href="print.html#find-all-files-with-given-pattern-ignoring-filename-case" id="find-all-files-with-given-pattern-ignoring-filename-case"><h2>Find all files with given pattern ignoring filename case.</h2></a>
<p><a href="https://docs.rs/glob/"><img src="https://badge-cache.kominick.com/crates/v/glob.svg?label=glob" alt="glob-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Find all image files in the <code>/media/</code> directory matching the <code>img_[0-9]*.png</code> pattern.</p>
<p>A custom <a href="https://docs.rs/glob/*/glob/struct.MatchOptions.html"><code>MatchOptions</code></a> struct is passed to the <a href="https://docs.rs/glob/*/glob/fn.glob_with.html"><code>glob_with</code></a> function making the glob pattern case insensitive while keeping the other options <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate glob;

use glob::{glob_with, MatchOptions};
#
# error_chain! {
#     foreign_links {
#         Glob(glob::GlobError);
#         Pattern(glob::PatternError);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let options = MatchOptions {
        case_sensitive: false,
        ..Default::default()
    };

    for entry in glob_with(&quot;/media/img_[0-9]*.png&quot;, &amp;options)? {
        println!(&quot;{}&quot;, entry?.display());
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-semver-increment"></a></p>
<a class="header" href="print.html#parse-and-increment-a-version-string" id="parse-and-increment-a-version-string"><h2>Parse and increment a version string.</h2></a>
<p><a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a> <a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a></p>
<p>Constructs a <a href="https://docs.rs/semver/*/semver/struct.Version.html"><code>semver::Version</code></a> from a string literal using <a href="https://docs.rs/semver/*/semver/struct.Version.html#method.parse"><code>Version::parse</code></a>, then increments it by patch, minor, and major version number one by one.</p>
<p>Note that in accordance with the <a href="http://semver.org/">Semantic Versioning Specification</a>, incrementing the minor version number resets the patch version number to 0 and incrementing the major version number resets both the minor and patch version numbers to 0.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate semver;

use semver::Version;
#
# error_chain! {
#     foreign_links {
#         SemVer(semver::SemVerError);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let mut parsed_version = Version::parse(&quot;0.2.6&quot;)?;

    assert_eq!(
        parsed_version,
        Version {
            major: 0,
            minor: 2,
            patch: 6,
            pre: vec![],
            build: vec![],
        }
    );

    parsed_version.increment_patch();
    assert_eq!(parsed_version.to_string(), &quot;0.2.7&quot;);
    println!(&quot;New patch release: v{}&quot;, parsed_version);

    parsed_version.increment_minor();
    assert_eq!(parsed_version.to_string(), &quot;0.3.0&quot;);
    println!(&quot;New minor release: v{}&quot;, parsed_version);

    parsed_version.increment_major();
    assert_eq!(parsed_version.to_string(), &quot;1.0.0&quot;);
    println!(&quot;New major release: v{}&quot;, parsed_version);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-semver-complex"></a></p>
<a class="header" href="print.html#parse-a-complex-version-string" id="parse-a-complex-version-string"><h2>Parse a complex version string.</h2></a>
<p><a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a> <a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a></p>
<p>Constructs a <a href="https://docs.rs/semver/*/semver/struct.Version.html"><code>semver::Version</code></a> from a complex version string using <a href="https://docs.rs/semver/*/semver/struct.Version.html#method.parse"><code>Version::parse</code></a>. The string
contains pre-release and build metadata as defined in the <a href="http://semver.org/">Semantic Versioning Specification</a>.</p>
<p>Note that, in accordance with the Specification, build metadata is parsed but not considered when
comparing versions. In other words, two versions may be equal even if their build strings differ.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate semver;

use semver::{Identifier, Version};
#
# error_chain! {
#     foreign_links {
#         SemVer(semver::SemVerError);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let version_str = &quot;1.0.49-125+g72ee7853&quot;;
    let parsed_version = Version::parse(version_str)?;

    assert_eq!(
        parsed_version,
        Version {
            major: 1,
            minor: 0,
            patch: 49,
            pre: vec![Identifier::Numeric(125)],
            build: vec![],
        }
    );
    assert_eq!(
        parsed_version.build,
        vec![Identifier::AlphaNumeric(String::from(&quot;g72ee7853&quot;))]
    );

    let serialized_version = parsed_version.to_string();
    assert_eq!(&amp;serialized_version, version_str);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-semver-prerelease"></a></p>
<a class="header" href="print.html#check-if-given-version-is-pre-release" id="check-if-given-version-is-pre-release"><h2>Check if given version is pre-release.</h2></a>
<p><a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a> <a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a></p>
<p>Given two versions, we assert (by using <a href="https://docs.rs/semver/*/semver/struct.Version.html#method.is_prerelease"><code>is_prerelease</code></a>) that one is pre-release and that the other is not.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate semver;

use semver::Version;
#
# error_chain! {
#     foreign_links {
#         SemVer(semver::SemVerError);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let version_1 = Version::parse(&quot;1.0.0-alpha&quot;)?;
    let version_2 = Version::parse(&quot;1.0.0&quot;)?;

    assert!(version_1.is_prerelease());
    assert!(!version_2.is_prerelease());

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-semver-latest"></a></p>
<a class="header" href="print.html#find-the-latest-version-satisfying-given-range" id="find-the-latest-version-satisfying-given-range"><h2>Find the latest version satisfying given range</h2></a>
<p><a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a> <a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a></p>
<p>Given a list of version &amp;strs, finds the latest <a href="https://docs.rs/semver/*/semver/struct.Version.html"><code>semver::Version</code></a> that satisfying a given <a href="https://docs.rs/semver/*/semver/struct.VersionReq.html"><code>semver::VersionReq</code></a> using <a href="https://docs.rs/semver/*/semver/struct.VersionReq.html#method.matches"><code>VersionReq::matches</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate semver;

use semver::{Version, VersionReq};
#
# error_chain! {
#     foreign_links {
#         SemVer(semver::SemVerError);
#         SemVerReq(semver::ReqParseError);
#     }
# }

fn find_max_matching_version&lt;'a, I&gt;(version_req_str: &amp;str, iterable: I) -&gt; Result&lt;Option&lt;Version&gt;&gt;
where
    I: IntoIterator&lt;Item = &amp;'a str&gt;,
{
    let vreq = VersionReq::parse(version_req_str)?;

    Ok(
        iterable
            .into_iter()
            .filter_map(|s| Version::parse(s).ok())
            .filter(|s| vreq.matches(s))
            .max(),
    )
}

fn run() -&gt; Result&lt;()&gt; {
    assert_eq!(
        find_max_matching_version(&quot;&lt;= 1.0.0&quot;, vec![&quot;0.9.0&quot;, &quot;1.0.0&quot;, &quot;1.0.1&quot;])?,
        Some(Version::parse(&quot;1.0.0&quot;)?)
    );

    // Shows Semver precedence for pre-release tags
    assert_eq!(
        find_max_matching_version(
            &quot;&gt;1.2.3-alpha.3&quot;,
            vec![
                &quot;1.2.3-alpha.3&quot;,
                &quot;1.2.3-alpha.4&quot;,
                &quot;1.2.3-alpha.10&quot;,
                &quot;1.2.3-beta.4&quot;,
                &quot;3.4.5-alpha.9&quot;,
            ]
        )?,
        Some(Version::parse(&quot;1.2.3-beta.4&quot;)?)
    );

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-semver-command"></a></p>
<a class="header" href="print.html#check-external-command-version-for-compatibility" id="check-external-command-version-for-compatibility"><h2>Check external command version for compatibility</h2></a>
<p><a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></p>
<p>Runs <code>git --version</code> using <a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>Command</code></a>, then parses the version number into a <a href="https://docs.rs/semver/*/semver/struct.Version.html"><code>semver::Version</code></a>
using <a href="https://docs.rs/semver/*/semver/struct.Version.html#method.parse"><code>Version::parse</code></a>. A <a href="https://docs.rs/semver/*/semver/struct.VersionReq.html"><code>semver::VersionReq</code></a> is used to compare the parsed version to a
minimum version requirement.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
extern crate semver;

use std::process::Command;
use semver::{Version, VersionReq};
#
# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#         Utf8(std::string::FromUtf8Error);
#         SemVer(semver::SemVerError);
#         SemVerReq(semver::ReqParseError);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let version_constraint = &quot;&gt; 1.12.0&quot;;
    let version_test = VersionReq::parse(version_constraint)?;
    let output = Command::new(&quot;git&quot;).arg(&quot;--version&quot;).output()?;

    if !output.status.success() {
        bail!(&quot;Command executed with failing error code&quot;);
    }

    let stdout = String::from_utf8(output.stdout)?;
    // `git --version` output: &quot;git version x.y.z&quot;
    let version = stdout.split(&quot; &quot;).last().ok_or_else(|| {
        &quot;Invalid command output&quot;
    })?;
    let parsed_version = Version::parse(version)?;

    if !version_test.matches(&amp;parsed_version) {
        bail!(&quot;Command version lower than minimum supported version (found {}, need {})&quot;,
            parsed_version, version_constraint);
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<!-- API Reference -->
<!-- Other Reference -->
<a class="header" href="print.html#logging" id="logging"><h1>Logging</h1></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="print.html#ex-log-debug">Log a debug message to the console</a> </td><td> <a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-log-error">Log an error message to the console</a> </td><td> <a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-log-mod">Enable log levels per module</a> </td><td> <a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-log-stdout">Log to stdout instead of stderr</a> </td><td> <a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-log-custom-logger">Log messages with a custom logger</a> </td><td> <a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-log-env-variable">Use a custom environment variable to set up logging</a> </td><td> <a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-log-timestamp">Include timestamp in log messages</a> </td><td> <a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> <a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-log-syslog">Log to the Unix syslog</a> </td><td> <a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/syslog/"><img src="https://badge-cache.kominick.com/crates/v/syslog.svg?label=syslog" alt="syslog-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-log-custom">Log messages to a custom location</a> </td><td> <a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/log4rs/"><img src="https://badge-cache.kominick.com/crates/v/log4rs.svg?label=log4rs" alt="log4rs-badge" /></a> </td><td> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a> </td></tr>
</tbody></table>
<p><a name="ex-log-debug"></a></p>
<a class="header" href="print.html#log-a-debug-message-to-the-console" id="log-a-debug-message-to-the-console"><h2>Log a debug message to the console</h2></a>
<p><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></p>
<p>The <code>log</code> crate provides logging utilities. The <code>env_logger</code> crate configures
logging via an environment variable.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate log;
extern crate env_logger;

fn execute_query(query: &amp;str) {
    debug!(&quot;Executing query: {}&quot;, query);

    // then do the thing
}

fn main() {
    env_logger::init();

    execute_query(&quot;DROP TABLE students&quot;);
}
</code></pre></pre>
<p>If you run this code, you'll notice that no output is printed. By default, the
log level is <code>error</code>, and any lower levels are dropped.</p>
<p>We can change that easily by setting the <code>RUST_LOG</code> environment variable:</p>
<pre><code>$ RUST_LOG=debug cargo run
</code></pre>
<p>After running this, you'll likely see a pile of logs from cargo, as well as the
following line at the very end of the output:</p>
<pre><code>DEBUG:main: Executing query: DROP TABLE students
</code></pre>
<p><a name="ex-log-error"></a></p>
<a class="header" href="print.html#log-an-error-message-to-the-console" id="log-an-error-message-to-the-console"><h2>Log an error message to the console</h2></a>
<p><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate log;
extern crate env_logger;
#
# #[macro_use]
# extern crate error_chain;
#
# error_chain! {
#     foreign_links {
#         SetLogger(log::SetLoggerError);
#     }
# }

fn execute_query(_query: &amp;str) -&gt; Result&lt;()&gt; {
    // Do the thing, or maybe not

    bail!(&quot;I'm afraid I can't do that&quot;)
}

fn run() -&gt; Result&lt;()&gt; {
    env_logger::init();

    let response = execute_query(&quot;DROP TABLE students&quot;);
    if let Err(err) = response {
        // Log the error message and continue
        error!(&quot;Failed to execute query: {}&quot;, err);
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p>Run this code with <code>cargo run</code> and you should see the following line:</p>
<pre><code>DEBUG:main: Failed to execute query: I'm afraid I can't do that
</code></pre>
<p><a name="ex-log-mod"></a></p>
<a class="header" href="print.html#enable-log-levels-per-module" id="enable-log-levels-per-module"><h2>Enable log levels per module</h2></a>
<p><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></p>
<p>Creates two modules <code>foo</code> and nested <code>foo::bar</code> with logging directives
controlled separately with <a href="https://docs.rs/env_logger/*/env_logger/#enabling-logging"><code>RUST_LOG</code></a> environmental variable.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate log;
extern crate env_logger;

mod foo {
    mod bar {
        pub fn run() {
            warn!(&quot;[bar] warn&quot;);
            info!(&quot;[bar] info&quot;);
            debug!(&quot;[bar] debug&quot;);
        }
    }

    pub fn run() {
        warn!(&quot;[foo] warn&quot;);
        info!(&quot;[foo] info&quot;);
        debug!(&quot;[foo] debug&quot;);
        bar::run();
    }
}

fn main() {
    env_logger::init();
    warn!(&quot;[root] warn&quot;);
    info!(&quot;[root] info&quot;);
    debug!(&quot;[root] debug&quot;);
    foo::run();
}
</code></pre></pre>
<p><a href="https://docs.rs/env_logger/"><code>env_logger</code></a> output is controlled by <a href="https://docs.rs/env_logger/*/env_logger/#enabling-logging"><code>RUST_LOG</code></a> environmental
variable on per module basis with comma separated entries in format <code>path::to::module=log_level</code>.
Running the <code>test</code> application as follows:</p>
<pre><code class="language-bash">RUST_LOG=&quot;warn,test::foo=info,test::foo::bar=debug&quot; ./test
</code></pre>
<p>Sets the default <a href="https://docs.rs/log/*/log/enum.Level.html"><code>log::Level</code></a> to <code>warn</code>, module's <code>foo</code> and module's <code>foo::bar</code>
respectively to <code>info</code> and <code>debug</code>. The output is:</p>
<pre><code class="language-bash">WARN:test: [root] warn
WARN:test::foo: [foo] warn
INFO:test::foo: [foo] info
WARN:test::foo::bar: [bar] warn
INFO:test::foo::bar: [bar] info
DEBUG:test::foo::bar: [bar] debug
</code></pre>
<p><a name="ex-log-stdout"></a></p>
<a class="header" href="print.html#log-to-stdout-instead-of-stderr" id="log-to-stdout-instead-of-stderr"><h2>Log to stdout instead of stderr</h2></a>
<p><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></p>
<p>Creates a custom logger configuration using the <a href="https://docs.rs/env_logger/*/env_logger/struct.Builder.html#method.target"><code>Builder::target</code></a> to set the target of the log output to <a href="https://docs.rs/env_logger/*/env_logger/fmt/enum.Target.html"><code>Target::Stdout</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate log;
extern crate env_logger;

use env_logger::{Builder, Target};

fn main() {
    Builder::new()
        .target(Target::Stdout)
        .init();

    error!(&quot;This error has been printed to Stdout&quot;);
}
</code></pre></pre>
<p><a name="ex-log-custom-logger"></a></p>
<a class="header" href="print.html#log-messages-with-a-custom-logger" id="log-messages-with-a-custom-logger"><h2>Log messages with a custom logger</h2></a>
<p><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></p>
<p>Implements a custom logger <code>ConsoleLogger</code> which prints to stdout.
In order to use the logging macros, <code>ConsoleLogger</code> implements
the <a href="https://docs.rs/log/*/log/trait.Log.html"><code>log::Log</code></a> trait and has to be installed via <a href="https://docs.rs/log/*/log/fn.set_logger.html"><code>log::set_logger</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate log;

use log::{Record, Level, Metadata, LevelFilter};

static CONSOLE_LOGGER: ConsoleLogger = ConsoleLogger;

struct ConsoleLogger;

impl log::Log for ConsoleLogger {
    fn enabled(&amp;self, metadata: &amp;Metadata) -&gt; bool {
        metadata.level() &lt;= Level::Info
    }

    fn log(&amp;self, record: &amp;Record) {
        if self.enabled(record.metadata()) {
            println!(&quot;Rust says: {} - {}&quot;, record.level(), record.args());
        }
    }

    fn flush(&amp;self) {}
}
#
# error_chain! {
#     foreign_links {
#         SetLogger(log::SetLoggerError);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    log::set_logger(&amp;CONSOLE_LOGGER)?;
    log::set_max_level(LevelFilter::Info);

    info!(&quot;hello log&quot;);
    warn!(&quot;warning&quot;);
    error!(&quot;oops&quot;);
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-log-env-variable"></a></p>
<a class="header" href="print.html#use-a-custom-environment-variable-to-set-up-logging" id="use-a-custom-environment-variable-to-set-up-logging"><h2>Use a custom environment variable to set up logging</h2></a>
<p><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></p>
<p>Logging is configured with <a href="https://docs.rs/env_logger/*/env_logger/struct.Builder.html"><code>Builder</code></a>.</p>
<p><a href="https://docs.rs/env_logger/*/env_logger/struct.Builder.html#method.parse"><code>Builder::parse</code></a> parses <code>MY_APP_LOG</code>
environmental variable contents in the form of <a href="https://docs.rs/env_logger/*/env_logger/#enabling-logging"><code>RUST_LOG</code></a> syntax.
Then <a href="https://docs.rs/env_logger/*/env_logger/struct.Builder.html#method.init"><code>Builder::init</code></a> initializes the logger.
All these steps are normally done internally by <a href="https://docs.rs/env_logger/*/env_logger/fn.init.html"><code>env_logger::init</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate log;
extern crate env_logger;

use std::env;
use env_logger::Builder;

fn main() {
    Builder::new()
        .parse(&amp;env::var(&quot;MY_APP_LOG&quot;).unwrap_or_default())
        .init();

    info!(&quot;informational message&quot;);
    warn!(&quot;warning message&quot;);
    error!(&quot;this is an error {}&quot;, &quot;message&quot;);
}
</code></pre></pre>
<p><a name="ex-log-timestamp"></a></p>
<a class="header" href="print.html#include-timestamp-in-log-messages" id="include-timestamp-in-log-messages"><h2>Include timestamp in log messages</h2></a>
<p><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> <a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></p>
<p>Creates a custom logger configuration with <a href="https://docs.rs/env_logger/*/env_logger/struct.Builder.html"><code>Builder</code></a>.
Each log entry calls <a href="https://docs.rs/chrono/*/chrono/offset/local/struct.Local.html#method.now"><code>Local::now</code></a> to get the current <a href="https://docs.rs/chrono/*/chrono/datetime/struct.DateTime.html"><code>DateTime</code></a> in local timezone and uses <a href="https://docs.rs/chrono/*/chrono/datetime/struct.DateTime.html#method.format"><code>DateTime::format</code></a> with <a href="https://docs.rs/chrono/*/chrono/format/strftime/index.html#specifiers"><code>strftime::specifiers</code></a> to format a timestamp used in the final log.</p>
<p>The example calls <a href="https://docs.rs/env_logger/*/env_logger/struct.Builder.html#method.format"><code>Builder::format</code></a> to set a closure which writes each
message text with timestamp, <a href="https://docs.rs/log/*/log/struct.Record.html#method.level"><code>Record::level</code></a> and body (<a href="https://docs.rs/log/*/log/struct.Record.html#method.args"><code>Record::args</code></a>).</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate log;
extern crate chrono;
extern crate env_logger;

use std::env;
use std::io::Write;
use chrono::Local;
use env_logger::Builder;

fn main() {
    Builder::new()
        .format(|buf, record| {
            write!(buf,
                &quot;{} [{}] - {}&quot;,
                Local::now().format(&quot;%Y-%m-%dT%H:%M:%S&quot;),
                record.level(),
                record.args()
            )
        })
        .parse(&amp;env::var(&quot;MY_APP_LOG&quot;).unwrap_or_default())
        .init();

    warn!(&quot;warn&quot;);
    info!(&quot;info&quot;);
    debug!(&quot;debug&quot;);
}
</code></pre></pre>
<p>Calling <code>MY_APP_LOG=&quot;info&quot; cargo run</code> will result in similar output:</p>
<pre><code>2017-05-22T21:57:06 [WARN] - warn
2017-05-22T21:57:06 [INFO] - info
</code></pre>
<p><a name="ex-log-syslog"></a></p>
<a class="header" href="print.html#log-to-the-unix-syslog" id="log-to-the-unix-syslog"><h2>Log to the Unix syslog</h2></a>
<p><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/syslog/"><img src="https://badge-cache.kominick.com/crates/v/syslog.svg?label=syslog" alt="syslog-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></p>
<p>Logs messages to <a href="https://www.gnu.org/software/libc/manual/html_node/Overview-of-Syslog.html">UNIX syslog</a>. Initializes logger backend
with <a href="https://docs.rs/syslog/*/syslog/fn.init.html"><code>syslog::init</code></a>. <a href="https://docs.rs/syslog/*/syslog/enum.Facility.html"><code>syslog::Facility</code></a> indicates type of program submitting log, <a href="https://docs.rs/log/*/log/enum.LevelFilter.html"><code>log::LevelFilter</code></a> denotes allowed log verbosity
and <code>Option&lt;&amp;str&gt;</code> holds optional application name.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #![allow(unused_imports)]
# #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate log;
# #[cfg(target_os = &quot;linux&quot;)]
extern crate syslog;

# #[cfg(target_os = &quot;linux&quot;)]
use syslog::Facility;
#
# #[cfg(target_os = &quot;linux&quot;)]
# error_chain! {
#     foreign_links {
#         SetLogger(syslog::Error);
#     }
# }

# #[cfg(target_os = &quot;linux&quot;)]
fn run() -&gt; Result&lt;()&gt; {
    syslog::init(Facility::LOG_USER,
                 log::LevelFilter::Debug,
                 Some(&quot;My app name&quot;))?;
    debug!(&quot;this is a debug {}&quot;, &quot;message&quot;);
    error!(&quot;this is an error!&quot;);
    Ok(())
}
#
# #[cfg(not(target_os = &quot;linux&quot;))]
# error_chain! {}
# #[cfg(not(target_os = &quot;linux&quot;))]
# fn run() -&gt; Result&lt;()&gt; {
#     Ok(())
# }
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-log-custom"></a></p>
<a class="header" href="print.html#log-messages-to-a-custom-location" id="log-messages-to-a-custom-location"><h2>Log messages to a custom location</h2></a>
<p><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/log4rs/"><img src="https://badge-cache.kominick.com/crates/v/log4rs.svg?label=log4rs" alt="log4rs-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></p>
<p>Configures log to be output into custom location with <a href="https://docs.rs/log4rs/">log4rs</a>. <a href="https://docs.rs/log4rs/">log4rs</a> can use either an external YAML file or a programmatically constructed configuration.</p>
<p>Firstly creates the log configuration with <a href="https://docs.rs/log4rs/*/log4rs/append/file/struct.FileAppender.html"><code>log4rs::append::file::FileAppender</code></a>
using a custom pattern from <a href="https://docs.rs/log4rs/*/log4rs/encode/pattern/index.html"><code>log4rs::encode::pattern</code></a>.</p>
<p>Secondly assigns it to the <a href="https://docs.rs/log4rs/*/log4rs/config/struct.Config.html"><code>log4rs::config::Config</code></a> which has a root appender that uses the previously created <code>logfile</code> appender. Subsequently sets the default <a href="https://docs.rs/log/*/log/enum.LevelFilter.html"><code>log::LevelFilter</code></a> so that any logs with <code>Info</code> level or higher will be sent to the logger.</p>
<pre><pre class="playpen"><code class="language-rust no_run"># #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate log;
extern crate log4rs;

use log::LevelFilter;
use log4rs::append::file::FileAppender;
use log4rs::encode::pattern::PatternEncoder;
use log4rs::config::{Appender, Config, Root};
#
# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#         LogConfig(log4rs::config::Errors);
#         SetLogger(log::SetLoggerError);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let logfile = FileAppender::builder()
        .encoder(Box::new(PatternEncoder::new(&quot;{l} - {m}\n&quot;)))
        .build(&quot;log/output.log&quot;)?;

    let config = Config::builder()
        .appender(Appender::builder().build(&quot;logfile&quot;, Box::new(logfile)))
        .build(Root::builder()
                   .appender(&quot;logfile&quot;)
                   .build(LevelFilter::Info))?;

    log4rs::init_config(config)?;

    info!(&quot;Hello, world!&quot;);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<!-- API Reference -->
<!-- Other Reference -->
<a class="header" href="print.html#build-time-tooling" id="build-time-tooling"><h1>Build Time Tooling</h1></a>
<p>This section covers &quot;build-time&quot; tooling, or code that is run prior to compiling a crate's source code.
Conventionally, build-time code lives in a <strong>build.rs</strong> file and is commonly referred to as a &quot;build script&quot;.
Common use cases include rust code generation and compilation of bundled C/C++/asm code.
See crates.io's <a href="http://doc.crates.io/build-script.html">documentation on the matter</a> for more information.</p>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="print.html#ex-cc-static-bundled">Compile and link statically to a bundled C library</a> </td><td> <a href="https://docs.rs/cc"><img src="https://badge-cache.kominick.com/crates/v/cc.svg?label=cc" alt="cc-badge" /></a> </td><td> <a href="https://crates.io/categories/development-tools"><img src="https://badge-cache.kominick.com/badge/development_tools--x.svg?style=social" alt="cat-development-tools-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-cc-static-bundled-cpp">Compile and link statically to a bundled C++ library</a> </td><td> <a href="https://docs.rs/cc"><img src="https://badge-cache.kominick.com/crates/v/cc.svg?label=cc" alt="cc-badge" /></a> </td><td> <a href="https://crates.io/categories/development-tools"><img src="https://badge-cache.kominick.com/badge/development_tools--x.svg?style=social" alt="cat-development-tools-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-cc-custom-defines">Compile a C library while setting custom defines</a> </td><td> <a href="https://docs.rs/cc"><img src="https://badge-cache.kominick.com/crates/v/cc.svg?label=cc" alt="cc-badge" /></a> </td><td> <a href="https://crates.io/categories/development-tools"><img src="https://badge-cache.kominick.com/badge/development_tools--x.svg?style=social" alt="cat-development-tools-badge" /></a> </td></tr>
</tbody></table>
<p><a name="ex-cc-static-bundled"></a></p>
<a class="header" href="print.html#compile-and-link-statically-to-a-bundled-c-library" id="compile-and-link-statically-to-a-bundled-c-library"><h2>Compile and link statically to a bundled C library</h2></a>
<p><a href="https://docs.rs/cc"><img src="https://badge-cache.kominick.com/crates/v/cc.svg?label=cc" alt="cc-badge" /></a> <a href="https://crates.io/categories/development-tools"><img src="https://badge-cache.kominick.com/badge/development_tools--x.svg?style=social" alt="cat-development-tools-badge" /></a></p>
<p>To accommodate scenarios where additional C, C++, or assembly is required in a project, the <a href="https://docs.rs/cc"><strong>cc</strong></a> crate
offers a simple api for compiling bundled C/C++/asm code into static libraries (<strong>.a</strong>) that can be statically linked to by <strong>rustc</strong>.</p>
<p>The following example has some bundled C code (<strong>src/hello.c</strong>) that will be used from rust.
Before compiling our rust source code, the &quot;build&quot; file (<strong>build.rs</strong>) specified in <strong>Cargo.toml</strong> will run.
Using the <a href="https://docs.rs/cc"><strong>cc</strong></a> crate, a static library file will be produced (in this case, <strong>libhello.a</strong>, see
<a href="https://docs.rs/cc/*/cc/struct.Build.html#method.compile"><code>compile</code> docs</a>) which can then be used from rust by declaring the external function signatures in an <code>extern</code> block.</p>
<p>Since the bundled C is very simple, only a single source file needs to be passed to <a href="https://docs.rs/cc/*/cc/struct.Build.html"><code>cc::Build</code></a>.
For more complex build requirements, <a href="https://docs.rs/cc/*/cc/struct.Build.html"><code>cc::Build</code></a> offers a full suite of builder methods for specifying
<a href="https://docs.rs/cc/*/cc/struct.Build.html#method.include"><code>include</code></a> paths and extra compiler <a href="https://docs.rs/cc/*/cc/struct.Build.html#method.flag"><code>flag</code></a>s.</p>
<a class="header" href="print.html#cargotoml" id="cargotoml"><h3><code>Cargo.toml</code></h3></a>
<pre><code class="language-toml">[package]
...
build = &quot;build.rs&quot;

[build-dependencies]
cc = &quot;1&quot;

[dependencies]
error-chain = &quot;0.11&quot;
</code></pre>
<a class="header" href="print.html#buildrs" id="buildrs"><h3><code>build.rs</code></h3></a>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate cc;

fn main() {
    cc::Build::new()
        .file(&quot;src/hello.c&quot;)
        .compile(&quot;hello&quot;);   // outputs `libhello.a`
}
</code></pre></pre>
<a class="header" href="print.html#srchelloc" id="srchelloc"><h3><code>src/hello.c</code></h3></a>
<pre><code class="language-c">#include &lt;stdio.h&gt;


void hello() {
    printf(&quot;Hello from C!\n&quot;);
}

void greet(const char* name) {
    printf(&quot;Hello, %s!\n&quot;, name);
}
</code></pre>
<a class="header" href="print.html#srcmainrs" id="srcmainrs"><h3><code>src/main.rs</code></h3></a>
<pre><code class="language-rust ignore"># #[macro_use] extern crate error_chain;
use std::ffi::CString;
use std::os::raw::c_char;
#
# error_chain! {
#     foreign_links {
#         NulError(::std::ffi::NulError);
#         Io(::std::io::Error);
#     }
# }
#
# fn prompt(s: &amp;str) -&gt; Result&lt;String&gt; {
#     use std::io::Write;
#     print!(&quot;{}&quot;, s);
#     std::io::stdout().flush()?;
#     let mut input = String::new();
#     std::io::stdin().read_line(&amp;mut input)?;
#     Ok(input.trim().to_string())
# }

extern {
    fn hello();
    fn greet(name: *const c_char);
}

fn run() -&gt; Result&lt;()&gt; {
    unsafe { hello() }
    let name = prompt(&quot;What's your name? &quot;)?;
    let c_name = CString::new(name)?;
    unsafe { greet(c_name.as_ptr()) }
    Ok(())
}
#
# quick_main!(run);
</code></pre>
<p><a name="ex-cc-static-bundled-cpp"></a></p>
<a class="header" href="print.html#compile-and-link-statically-to-a-bundled-c-library-1" id="compile-and-link-statically-to-a-bundled-c-library-1"><h2>Compile and link statically to a bundled C++ library</h2></a>
<p><a href="https://docs.rs/cc"><img src="https://badge-cache.kominick.com/crates/v/cc.svg?label=cc" alt="cc-badge" /></a> <a href="https://crates.io/categories/development-tools"><img src="https://badge-cache.kominick.com/badge/development_tools--x.svg?style=social" alt="cat-development-tools-badge" /></a></p>
<p>Linking a bundled C++ library is very similar to linking a bundled C library. The two core differences when compiling and statically linking a bundled C++ library are specifying a C++ compiler via the builder method <a href="https://docs.rs/cc/*/cc/struct.Build.html#method.cpp"><code>cpp(true)</code></a> and preventing name mangling by the C++ compiler by adding the <code>extern &quot;C&quot;</code> section at the top of our C++ source file.</p>
<a class="header" href="print.html#cargotoml-1" id="cargotoml-1"><h3><code>Cargo.toml</code></h3></a>
<pre><code class="language-toml">[package]
...
build = &quot;build.rs&quot;

[build-dependencies]
cc = &quot;1&quot;
</code></pre>
<a class="header" href="print.html#buildrs-1" id="buildrs-1"><h3><code>build.rs</code></h3></a>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate cc;

fn main() {
    cc::Build::new()
        .cpp(true)
        .file(&quot;src/foo.cpp&quot;)
        .compile(&quot;foo&quot;);   
}
</code></pre></pre>
<a class="header" href="print.html#srcfoocpp" id="srcfoocpp"><h3><code>src/foo.cpp</code></h3></a>
<pre><code class="language-cpp">extern &quot;C&quot; {
    int multiply(int x, int y);
}

int multiply(int x, int y) {
    return x*y;
}
</code></pre>
<a class="header" href="print.html#srcmainrs-1" id="srcmainrs-1"><h3><code>src/main.rs</code></h3></a>
<pre><code class="language-rust ignore">extern {
    fn multiply(x : i32, y : i32) -&gt; i32;
}

fn main(){
    unsafe {
        println!(&quot;{}&quot;, multiply(5,7));
    }   
}
</code></pre>
<p><a name="ex-cc-custom-defines"></a></p>
<a class="header" href="print.html#compile-a-c-library-while-setting-custom-defines" id="compile-a-c-library-while-setting-custom-defines"><h2>Compile a C library while setting custom defines</h2></a>
<p><a href="https://docs.rs/cc"><img src="https://badge-cache.kominick.com/crates/v/cc.svg?label=cc" alt="cc-badge" /></a> <a href="https://crates.io/categories/development-tools"><img src="https://badge-cache.kominick.com/badge/development_tools--x.svg?style=social" alt="cat-development-tools-badge" /></a></p>
<p>It is simple to build bundled C code with custom defines using <a href="https://docs.rs/cc/*/cc/struct.Build.html#method.define"><code>cc::Build::define</code></a>.
It takes an <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> value, so it is possible to create defines such as <code>#define APP_NAME &quot;foo&quot;</code>
as well as <code>#define WELCOME</code> (pass <code>None</code> as the value for a value-less define). This example builds
a bundled C file with dynamic defines set in <code>build.rs</code> and prints &quot;<strong>Welcome to foo - version 1.0.2</strong>&quot;
when run. Cargo sets some <a href="http://doc.crates.io/environment-variables.html#environment-variables-cargo-sets-for-crates">environment variables</a> which may be useful for some custom defines.</p>
<a class="header" href="print.html#cargotoml-2" id="cargotoml-2"><h3><code>Cargo.toml</code></h3></a>
<pre><code class="language-toml">[package]
...
version = &quot;1.0.2&quot;
build = &quot;build.rs&quot;

[build-dependencies]
cc = &quot;1&quot;
</code></pre>
<a class="header" href="print.html#buildrs-2" id="buildrs-2"><h3><code>build.rs</code></h3></a>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate cc;

fn main() {
    cc::Build::new()
        .define(&quot;APP_NAME&quot;, &quot;\&quot;foo\&quot;&quot;)
        .define(&quot;VERSION&quot;, format!(&quot;\&quot;{}\&quot;&quot;, env!(&quot;CARGO_PKG_VERSION&quot;)).as_str())
        .define(&quot;WELCOME&quot;, None)
        .file(&quot;src/foo.c&quot;)
        .compile(&quot;foo&quot;);
}
</code></pre></pre>
<a class="header" href="print.html#srcfooc" id="srcfooc"><h3><code>src/foo.c</code></h3></a>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void print_app_info() {
#ifdef WELCOME
    printf(&quot;Welcome to &quot;);
#endif
    printf(&quot;%s - version %s\n&quot;, APP_NAME, VERSION);
}
</code></pre>
<a class="header" href="print.html#srcmainrs-2" id="srcmainrs-2"><h3><code>src/main.rs</code></h3></a>
<pre><code class="language-rust ignore">extern {
    fn print_app_info();
}

fn main(){
    unsafe {
        print_app_info();
    }   
}
</code></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<!-- Other Reference -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

    </body>
</html>
